/**
 * Copyright (C) Transmit Security, LTD - All Rights Reserved 
 * Unauthorized copying of this file, via any medium is strictly prohibited 
 * Proprietary and confidential 
 * Generated using tsidlc. 
 */

declare namespace com.ts.mobile.sdk {

   /** Represents a geolocation coordinate. */
   export class GeoLocation {
      /** Longtitude of coordinate */
      longitude: number;
      /** Latitude of coordinate */
      latitude: number;
   }
/**
 * Describes the versions of the elements which comprise the Transmit SDK APIs.
 *
 */
export interface VersionInfo { 

/**
 * The version of the *native* services SDK, e.g. "major.minor.patch.patch2-preRelease (buildNumber)" Where:
 *  - major AND minor are mandatory numeric values
 *  - patch AND patch2 are optional numeric values
 *  - preRelease is an optional string containing alphanumeric characters and hyphens and preceded by a hyphen
 *  - buildNumber is an optional numeric value wrapped with parentheses and possibly preceded by any number of spaces
 *
 * An example for a concrete full-form version string: "5.1.0.0-RC2-SNAPSHOT  (1080)"
 */
   getSdkVersion() : string;

/**
 * The name of the native platform, e.g. "android".
 */
   getPlatformName() : string;

/**
 * The "version" of the APIs which this package provides.
 */
   getApiLevel() : number;

/**
 * The version of the *core* services SDK. Has the same structure as described for sdkVersion above.
 */
   getTarsusVersion() : string;
}
/**
 * Final result of a successful authentication request. This object is returned from the SDK following a successful
 * completion of policy evaluation, and contains information about the evaluation as well as an optional authentication
 * token.
 *
 */
export interface AuthenticationResult { 

/**
 * Authentication token, if one was generated as part of this policy evaluation.
 */
   getToken() : string;

/**
 * Device ID
 */
   getDeviceId() : string;

/**
 * Additional data attached by the policy at completion.
 */
   getData() : object;
}
/**
 * Possible reasons for authentication errors.
 *
 */
export enum AuthenticationErrorCode {
       /** General internal SDK error. */
   Internal,
       /** Invalid input received from authenticator. */
   InvalidInput,
       /** Authenticator locked. Typically passed to an authenticator context when it is locked and other authenticators areavailable.*/
   AuthenticatorLocked,
       /** All authenticators are locked. Typically passed to an authenticator context when it is locked and no other authenticator is available. */
   AllAuthenticatorsLocked,
       /** No registered authenticator exists, and one is required. */
   NoRegisteredAuthenticator,
       /** Attempt to register an authenticator with input that was used in the past. */
   RegisteredSecretAlreadyInHistory,
       /** Error communicating with the server. */
   Communication,
       /** Request not completed due to user cancellation request. */
   UserCanceled,
       /** Callback implementation behaved unexpectedly */
   AppImplementation,
       /** Policy requested to reject the evaluation */
   PolicyRejection,
       /** Authenticator was invalidated from some reason. User is expected to re-register the authenticator. */
   AuthenticatorInvalidated,
       /** Control flow execution session expired our not found. */
   ControlFlowExpired,
       /** SDK operation requires an active session, and one doesn't exist (or expired) */
   SessionRequired,
       /** The authenticator cannot authenticate the user due to an authenticator-originating error -- as opposed to bad credentials. */
   AuthenticatorError,
       /** An approval is in the wrong state for performing an operation on it. */
   ApprovalWrongState,
       /** TOTP generation session is requested for user when TOTP wasn't provisioned for user. */
   TotpNotProvisioned,
       /** The authenticator cannot authenticate the user because of a user-servicable configuration issue outside the scope of the SDK */
   AuthenticatorExternalConfigError,
       /** The device binding is invalid; typically indicated by the server. Application should attempt to re-bind the device. */
   InvalidDeviceBinding,
       /** The id token in use is invalid; typically indicated by the server. Application should attempt to re-bind the device using a userId. */
   InvalidIdToken,
       /** Requested device was not found in the list of users devices. */
   DeviceNotFound,
       /** Approval was denied on mobile app. */
   ApprovalDenied,
       /** Approval has expired. */
   ApprovalExpired,
       /** An error generated by the application; the SDK doesn't attribute any semantics to these errors */
   ApplicationGeneratedRecoverableError,
       /** The user handle provided to the operation does not map to any user record in the local state */
   UserNotFound
}

/**
 * Keys for retreiving additional information describing the related error codes.
 *
 */
export enum AuthenticationErrorProperty {
       /** A property used to describe the reason which caused an {@link AuthenticationErrorCode#AuthenticatorExternalConfigError} report. */
   AuthenticatorExternalConfigErrorReason,
       /** A property used to describe the reason which caused an {@link AuthenticationErrorCode#InvalidInput} report. */
   AuthenticatorInvalidInputErrorDescription,
       /** A property used to describe the reason which caused an {@link AuthenticationErrorCode#InvalidIdToken} report. */
   InvalidIdTokenErrorReason,
       /** A property used to indicate whether the user's record (and device binding) was deleted as a result of the error. This will be present if the SDK is configured for auto recovery from errors that indicate such deletion is required.  */
   UserRecordDeleted,
       /** An optional string property used to represent the policy action type during which execution the error occurred. */
   AuthenticationErrorFailingActionType,
       /** An optional property used to describe the reason which caused an authentication error. */
   AuthenticationErrorReason
}

/**
 * AuthenticationError specific Property values.
 *
 */
export enum AuthenticationErrorPropertySymbol {
       /** Property value for {@link AuthenticationErrorProperty#AuthenticatorExternalConfigErrorReason} indicating no fingerprints enrolled on the device */
   AuthenticatorExternalConfigErrorReasonBiometricsNotEnrolled,
       /** Property value for {@link AuthenticationErrorProperty#AuthenticatorExternalConfigErrorReason} indicating fingerprint authentication on the device is temporarily locked due to too many failed attempts. */
   AuthenticatorExternalConfigErrorReasonBiometricsOsLockTemporary,
       /** Property value for {@link AuthenticationErrorProperty#AuthenticatorExternalConfigErrorReason} indicating fingerprint authentication on the device is locked until the user uses the psscode to unlock it. */
   AuthenticatorExternalConfigErrorReasonBiometricsOsLockPermanent,
       /** Property value for {@link AuthenticationErrorProperty#AuthenticatorInvalidInputErrorDescription} indicating TOTP authentication failed due to incorrect check digit. */
   AuthenticatorInvalidInputErrorDescriptionTotpIncorrectCheckDigit,
       /** Property value for {@link AuthenticationErrorProperty#InvalidIdTokenErrorReason} indicating the id token in use has expired */
   InvalidIdTokenErrorReasonExpiredToken,
       /** Property value for {@link AuthenticationErrorProperty#InvalidIdTokenErrorReason} indicating the id token in use does not match the one expected by the server */
   InvalidIdTokenErrorReasonBadToken,
       /** Property value for {@link AuthenticationErrorProperty#AuthenticationErrorReason} indicating attestation reverification failed for the credential */
   AuthenticationErrorReasonAttestationReverificationFailed,
       /** Property value for {@link AuthenticationErrorProperty#AuthenticationErrorReason} indicating the credential didn't pass the credential filter */
   AuthenticationErrorReasonCredentialFiltered,
       /** Property value for {@link AuthenticationErrorProperty#AuthenticatorExternalConfigErrorReason} indicating device signing key pair generation failure.  */
   AuthenticatorExternalConfigErrorReasonGeneratedKeyIsNotSecure
}

/**
 * UI Assets download mode.
 *
 */
export enum UIAssetsDownloadMode {
       /** Disable download assets from the server and use the local assets. */
   Disable,
       /** Download the assets from the server once the SDK has been initialized. */
   DownloadOnInit
}

/**
 * Invalid user record error recovery mode.
 *
 */
export enum InvalidUserRecordRecoveryMode {
       /** Disable atomatic recovery of user record errors. It is the application's respobsibility to respond to these errors by clearing the user record as needed. */
   Disable,
       /** Delete user record when encountering DeviceNotFound or InvalidDeviceBinding errors during an authentication call. This only affects calls to {@link TransmitSdkXm#authenticate}. */
   RecoverDeviceAndBindingOnAuthenticate
}

export abstract class AuthenticationError { 

/**
 * Error code
 */
   public getErrorCode() : AuthenticationErrorCode;

/**
 * Error message
 */
   public getMessage() : string;

/**
 * Additional error-specific data
 */
   public getData() : object;

/**
 * Create an authentication error object with  code ApplicationGeneratedRecoverableError.
 */
   public static createApplicationGeneratedGeneralError(message: string, data: object) : AuthenticationError;

/**
 * Create an authentication error object with code Communication.
 */
   public static createApplicationGeneratedCommunicationError(message: string, data: object) : AuthenticationError;

   /** Retrieves a specific **string** property attached to this error object where relevant (e.g. when {@link errorCode} equals {@link AuthenticationErrorCode#AuthenticatorExternalConfigError}).
 *
 * @param property The key for the property to retrieve.
 *
 * @return The property value matching the requested type or *null* if not present.
 * @throws AuthenticationError in case the property being retrieved is not of string type..
 */
public abstract getPublicStringProperty(property: AuthenticationErrorProperty) : string;

   /**
 * Retrieves a specific **number** property attached to this error object where relevant (e.g. when {@link errorCode} equals {@link AuthenticationErrorCode#AuthenticatorExternalConfigError}).
 *
 * @param property The key for the property to retrieve.
 *
 * @return The property value matching the requested type or *null* if not present.
 * @throws AuthenticationError in case the property being retrieved is not of number type.
 */
public abstract getPublicNumberProperty(property: AuthenticationErrorProperty) : number;

   /**
 * Retrieves a specific **boolean** property attached to this error object where relevant (e.g. when {@link errorCode} equals {@link AuthenticationErrorCode#AuthenticatorExternalConfigError}).
 *
 * @param property The key for the property to retrieve.
 *
 * @return The property value matching the requested type or *null* if not present.
 * @throws AuthenticationError in case the property being retrieved is not of boolean type.
 */
public abstract getPublicBooleanProperty(property: AuthenticationErrorProperty) : boolean;

   /**
 * Retrieves a specific **{@link AuthenticationErrorPropertySymbol}** property attached to this error object where relevant (e.g. when {@link errorCode} equals {@link AuthenticationErrorCode#AuthenticatorExternalConfigError}).
 *
 * @param property The key for the property to retrieve.
 *
 * @return The property value matching the requested type or *null* if not present.
 * @throws AuthenticationError in case the property being retrieved is not of type AuthenticationErrorPropertySymbol.
 */
public abstract getPublicSymbolicProperty(property: AuthenticationErrorProperty) : AuthenticationErrorPropertySymbol;
}
export interface TSColor { 

/**
 * hex representation of the color in the following available formats.
 * #AARRGGBB , #ARGB, #RGB, #RRGGBB
 */
   getHexValue() : string;
}
export interface UIStyle { 

/**
 * Background color of element
 */
   getBackgroundColor() : TSColor | null;

/**
 * Tint color of element
 */
   getTintColor() : TSColor | null;

/**
 * Line color of element
 */
   getLineColor() : TSColor | null;

/**
 * Icon color of element
 */
   getIconColor() : TSColor | null;

/**
 * Image URL of element
 */
   getImageUrl() : string | null;

/**
 * Font name for element
 */
   getFontName() : string | null;

/**
 * Font size for element
 */
   getFontSize() : number | null;

/**
 * Should font be bold?
 */
   getFontBold() : boolean | null;

/**
 * Should input be masked?
 */
   getMaskInput() : boolean | null;
}
export interface UIContext { 

   /**
 * API to get the localized string by the key from the server strings table, if the string doesn't exist
 * it will search for the string in the local localization strings table else will return the key.
 *
 * @param key a string to retrive the localized string from strings table.
 *
 * @return a localized string
 */
getString(key: string) : string;

   /**
 * API to get a localized string by the key from the server strings table with the ability to define arguments for interpolation,
 * if the string doesn't exist, it will search for the string in the local localization strings table else will return the key.
 * if the interpolation args are less, it will return the partial result with the interpolation tags for missing args.
 * if the interpolation args are more, it will ignore the additional tags.
 *
 * @param key a string to retrieve the localized string from strings table.
 * @param args a list of strings for interpolation.
 *
 * @return a localized string after interpolation.
 */
formatString(key: string, args: Array<string> | null) : string;

   /**
 * API to get UI style
 *
 * @param tags list of
 *
 * @return the style object matching the tags or null
 */
getStyle(tags: Array<string>) : UIStyle;
}
/**
 * A hint to the UI layer regarding how an escape option should be rendered
 * on screen.
 */
export enum ActionEscapeOptionPresentation {
       /** Do not render this escape option */
   Hide,
       /** This escape option is an auxiliary action that the user should be offered a chance to invoke */
   Action,
       /** This escape option should be invoked when the user clicks on a button that suggests cancellation of the action */
   Cancel,
       /** Reserved for custom Transmit Security Implementations */
   Custom
}

/**
 * Represents a UI escpae option defined for an action. UI escape options allow user-actions
 * to abort their intended operation and signal to the Transmit Server that journey execution
 * should resume in an alternate path. Journeys may attach escape options to actions, and these escape
 * options define alternate execution paths.
 * UI handlers receive information on the escape options attached to an action via instances of this
 * interface. They also identify escape options to invoke by providing back these instances to
 * relevant SDK API calls.
 * UI handlers may choose to render UI to allow the user to invoke escape options, or otherwise decide
 * to invoke them.
 */
export interface ActionEscapeOption { 

/**
 * An ID assigned to the escape option.
 */
   getId() : string;

/**
 * A value hinting the UI layer how the escape option should be presented to the user.
 */
   getPresentation() : ActionEscapeOptionPresentation;

/**
 * A string label decribing the escape option to the user. How this value is rendered in the UI,
 * if at all, is up to the UI layer implementation which should also take into account the #presentation
 * attribute of the escape option.
 */
   getDisplayName() : string | null;
}
/**
 * Represents a request from the UI layer to the SDK to invoke an escape option. Objects of these types
 * are passed in return from various UI sessions to signal to the SDK that an escape option should be
 * invoked. They identify the escape option to invoke as well as additional optional parameters to pass to it.
 */
export class ActionEscapeRequest { 

/**
 * The object identifying the escape option to invoke.
 */
   public getEscapeOption() : ActionEscapeOption;

/**
 * The object identifying the escape option to invoke.
 */
   public setEscapeOption(escapeOption : ActionEscapeOption) : void;

/**
 * An additional JSON object to include with the escape option invocation request.
 * This data will be made available to the journey when the escape option is invoked.
 */
   public getEscapeParameters() : object | null;

/**
 * An additional JSON object to include with the escape option invocation request.
 * This data will be made available to the journey when the escape option is invoked.
 */
   public setEscapeParameters(escapeParameters : object | null) : void;
}
/**
 * Provides information on the currently executed action in a policy. This class is provided by the SDK to the client
 * on callback invocations to allow the client to access information about the action during its execution.
 *
 */
export interface PolicyAction { 

/**
 * Used to distinguish between a journey-originated action and an action that was initiated on the client.
 * If this property is true ??? then the action did not originate from the server for example, for authentication as part of local TOTP generation.
 * Otherwise this will be false.
 */
   getIsPseudoAction() : boolean;

/**
 * Type of this action.
 */
   getActionType() : string;

/**
 * Action alternative label
 */
   getAltLabel() : string;

/**
 * UIContext contains ui utils.
 */
   getUiContext() : UIContext;

/**
 * Available escape options from action. Depending on the executing action,
 * one of these options can be provided to abort action completion and
 * take a different path in the control flow.
 */
   getEscapeOptions() : Array<ActionEscapeOption>;

   /**
 * Find an escape option based on ID sent from the server.
 */
escapeOptionById(escapeOptionName: string) : ActionEscapeOption;
}
/**
 * Type of authentication UI session control request. Defines how the authentication flow should be changed in response
 * to the control request from an authentication UI session.
 *
 */
export enum ControlRequestType {
       /** Cancel the authenticator. This will trigger invoking the UIHandler#controlOptionForCancellationRequestInSession callback to obtain an alternative control request */
   CancelAuthenticator,
       /** Retry authenticating using the current authenticator. */
   RetryAuthenticator,
       /** Allow the user to change the authentication method (not the current one) */
   ChangeMethod,
       /** Allow the user to select an authentication method (the current one or another one) */
   SelectMethod,
       /** Abort the authentication process altogether, returning an error from the SDK invocation */
   AbortAuthentication
}

/**
 * Represents a control request from a UI authenticator session, asking to change or terminate the authentication
 * flow.
 *
 */
export abstract class ControlRequest { 

/**
 * Type of contorl request.
 */
   public getRequestType() : ControlRequestType;

/**
 * Type of contorl request.
 */
   public setRequestType(requestType : ControlRequestType) : void;

/**
 * Create a control request with the specified request type.
 *
 * @param requestType Type of control request to create.
 */
   public static create(requestType: ControlRequestType) : ControlRequest;
}
/**
 * Supertype for all authenticator input resposne types.
 */
export class InputResponseType { 
}
/**
 * Communicates either an input response, a control response or an escape request from a UI
 * session (e.g an authenticator UI session or a QR scan UI session) to the SDK.
 * This is a container that can contain either an InputResponseType object, an ActionEscapeOption object,
 * **or** a ControlRequest object.
 *
 */
export abstract class InputOrControlResponse<ResponseType extends InputResponseType> { 

   /**
 * Is this a control request?
 *
 * @return true if this object contains a control request (obtained through the controlRequest property), false if it contains an input response (obtained through the response property)
 */
public abstract isControlRequest() : boolean;

/**
 * The input response, if this object represents an input response.
 */
   public getResponse() : ResponseType;

/**
 * The input response, if this object represents an input response.
 */
   public setResponse(response : ResponseType) : void;

/**
 * The control request, if this object represents a control request.
 */
   public getControlRequest() : ControlRequest;

/**
 * The control request, if this object represents a control request.
 */
   public setControlRequest(controlRequest : ControlRequest) : void;

/**
 * An escape option, if this object represents an escape request.
 */
   public getActionEscapeRequest() : ActionEscapeRequest;

/**
 * An escape option, if this object represents an escape request.
 */
   public setActionEscapeRequest(actionEscapeRequest : ActionEscapeRequest) : void;

/**
 * Create an InputOrControlResponse object representing a control request.
 *
 * @param controlRequest the ControlRequest to represent in the created object.
 */
   public static createControlResponse<ResponseType extends InputResponseType>(controlRequest: ControlRequest) : InputOrControlResponse<ResponseType>;

/**
 * Create an InputOrControlResponse object representing an escape request --
 * branching through an escape not in the action.
 *
 * @param escapeOption the ActionEscapeOption to represent in the created object.
 * @param escapeParameters Parameters to pass to the journey when taking the escape branch.
 */
   public static createEscapeResponse<ResponseType extends InputResponseType>(escapeOption: ActionEscapeOption, escapeParameters: object | null) : InputOrControlResponse<ResponseType>;

/**
 * Create an InputOrControlResponse object representing an authenticator input response.
 *
 * @param inputResponse the input response to represent in the created object.
 */
   public static createInputResponse<ResponseType extends InputResponseType>(inputResponse: ResponseType) : InputOrControlResponse<ResponseType>;
}
/**
 * Type of error recovery actions available to authentication sessions.
 *
 */
export enum AuthenticationErrorRecovery {
       /** Retry authentication using the current authenticator (and within the current session). */
   RetryAuthenticator,
       /** End the UI session and switch to a different authenticator. This is only valid if there is an authenticator available other than the present one.*/
   ChangeAuthenticator,
       /** End the UI session and go to the auhtneticator selection menu. */
   SelectAuthenticator,
       /** Abort policy execution and fail the authentication process. */
   Fail
}

/**
 * Authenticator UI session modes.
 *
 */
export enum AuthenticatorSessionMode {
       /** Session used for authenticating using an authenticator */
   Authentication,
       /** Session used for enrolling / registering an authenticator. */
   Registration
}

/**
 * Authenticator types / modalities.
 *
 */
export enum AuthenticatorType {
   
   Password,
   
   Fingerprint,
   
   Pincode,
   
   Pattern,
   
   Otp,
   
   Face,
   
   Voice,
   
   Eye,
   
   Emoji,
   
   Questions,
   
   FaceID,
   
   Generic,
   
   MobileApprove,
   
   Totp,
   
   DeviceBiometrics,
   
   Fido2
}

/**
 * Authenticator registration status
 *
 */
export enum AuthenticatorRegistrationStatus {
       /** Authenticator is registered for this device (or centrally) */
   Registered,
       /** Authenticator is not registered for this device (or centrally) due to registration not occurring or unregistration ocurring */
   Unregistered,
       /** Authenticator is not registered for this device (or centrally) due to invalidation of registration on device */
   LocallyInvalid
}

/**
 * Describes an authenticator. This includes general description
 * of the authenticator and its status.
 *
 */
export interface AuthenticatorDescription { 

/**
 * Programmatic ID of the authenticator.
 */
   getAuthenticatorId() : string;

/**
 * Authenticator type.
 */
   getType() : AuthenticatorType;

/**
 * Readable name of this authenticator.
 */
   getName() : string;

/**
 * true if the authenticator is expired (and will thus typically require registration after authentication).
 */
   getExpired() : boolean;

/**
 * true if the authenticator is registered for the current user and app (registrationStatus == Registered)
 */
   getRegistered() : boolean;

/**
 * Registration state of authenticator.
 */
   getRegistrationStatus() : AuthenticatorRegistrationStatus;

/**
 * true if the authenticator is locked.
 */
   getLocked() : boolean;

/**
 * true if this authenticator is designated as the "default authenticator" for the user (the last used authenticator).
 */
   getDefaultAuthenticator() : boolean;

/**
 * true if the authenticator can be supported on the present device.
 */
   getSupportedOnDevice() : boolean;

/**
 * true if the authenticator can be used during this authentication action and on the current device -- taking into
 * account factors such as locking, registration  and device support
 */
   getEnabled() : boolean;

/**
 * If exists, the UI can present a credential recovery link that will branch to specific journey branch on the server.
 * If user expresses intent, the UI can invoke this escape option.
 */
   getCredentialRecoveryEscapeOption() : ActionEscapeOption | null;
}
/**
 * A base value-type, representing a parameter setting for an authentication action. Concnrete parameter settings
 * are derived from this object. An authetnication action can be subject to multiple such parameters.
 * The permitted parameters and their semantics is dependent upon the authentication method.
 */
export class AuthenticationActionParameter { 
}
/**
 * A single entry in an authentication action menu. The entry comprises of an authenticator type
 * and a set of possible / suggested parameters for use with that authenticator type.
 */
export interface AuthenticationOption { 

/**
 * Authenticator type represented by this authentication option.
 */
   getAuthenticator() : AuthenticatorDescription;

/**
 * Suggested parameters for this authentication option. Note that it's possible that
 * the authenticator supports parameters additional to the ones specified in this list;
 * this is just a recommendation.
 * Specific authenticators may define the exact set of parameters that's included in this list.
 */
   getSuggestedParameters() : Array<AuthenticationActionParameter>;
}
/**
 * An interface for managing an authenticator UI session. When the SDK needs to invoke an authenticator, it does that
 * in the context of an authenticator UI session. An authenticator UI session is started once an authenticator is
 * selected, and ends when authentication using the authenticator completes, or is aborted (e.g due to the user
 * choosing a different authenticator or cancelling an authentication action altogether).
 *
 * An authenticator session can be in one of two modes (represented by AuthenticatorSessionMode) -- authentication
 * (Authentication) or registration (Registration). The mode is set on session start, but may change during the
 * session. For example, when authenticating with an expired authenticator, the session mode will change from
 * authentication to registration rather than starting a separate UI session for the registration action. This allows
 * the client to distinguish between registration done in the same context as the (expired) authentication vs.
 * a standalone registration session.
 *
 * A session class is associated with a response type -- the type of session response input. This is the type used
 * to relay input from the authenticator session to the SDK. Authenticator UI sessions for different authenticator
 * types would use different response types.
 *
 * The session lifecycle always begins with a call to startSession, done by the SDK shortly after the session object
 * is created through one of the createXXXXAuthSession methods in UIHandler. With startSession the session receives
 * the initial session mode and the clientContext for the SDK operation invocation within which the session is created.
 *
 * After the call to startSession, the SDK will call promiseInput() -- asking the UI session to collect and provide
 * input from the user. For some authenticators, the input may be one of several classes with a common base class;
 * for others the input may be a concrete class. For example, for the password authenticator, the input would be
 * the password input by the user. In addition to authenticator input, promiseInput may also return a control
 * request -- affecting the processing of the authentication action. A control request may, for example, signal that
 * the authentication process should be aborted or that the user should be offered to change an authenticator. For a
 * list of possible control requests see the ControlRequestType enum.
 *
 * Once inputPromise returns an input the SDK processes it. It then may report an error in processing -- by
 * invoking promiseRecoveryForError. If there's no error, the SDK may invoke promiseInput again to ask for additional
 * input. If the authenticator is expired, and the SDK now needs to register a new secret for it,
 * it would invoke changeSessionModeToRegistrationAfterExpiration.
 *
 * When the SDK can complete the authentication flow based on the input received from  promiseInput, or
 * when the SDK needs to otherwise end the session due to a control request or an error condition, it will invoke
 * endSession to signal that the authentication session has ended.
 *
 */
export interface UIAuthenticatorSession<ResponseType extends InputResponseType> { 

   /**
 * Called to start the authenticator UI session. This is the first function invoke on the session by the SDK.
 * Its purpose is to setup the UI and associate it with the clientContext of the current running authentication
 * action.
 *
 * Implementations should prepare the UI for interaction with the authenticator -- typically (but not necessarily)
 * presenting new UI elements on screen, recording the clientContext and setting the UI to the session mode provided.
 *
 * @param description Decription of the authenticator and settings for this session.
 * @param mode The initial mode for this session (authenticate / register)
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked. This is optional since session may be invoked outside the scope of an action.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 */
startSession(description: AuthenticatorDescription, mode: AuthenticatorSessionMode, actionContext: PolicyAction | null, clientContext: object | null) : void;

   /**
 * Change the session mode to registration due to an expired authenticator. This method is invoked by the SDK when
 * during a session it needs to switch from authentication to registration of the authenticator -- due to
 * an expired authenticator is being used for authentication (after successful authentication the SDK will invoke
 * this method to switch to registration mode for the authenticator).
 *
 * Implementations should make the user aware that they are now registering a new secret for the authenticator,
 * possible showing an alert or other visual cue, and then setup the UI accordingly to support registration. The
 * implementation should make it known to the user that this is done due to an expired authenticator.
 *
 */
changeSessionModeToRegistrationAfterExpiration() : void;

   /**
 * Notify the session that an error has occurred processing input. This function is invoked by the SDK if it
 * encounters an error processing the input provided to it on return from promiseInput. The SDK provides the
 * encountered error, and the session should asynchronously return a recovery action instructing the SDK
 * how to respond to this error.
 *
 * See AuthenticationErrorRecovery for a list of recovery options.
 *
 * Implementations should examine the error and based on its nature decide how to communicate it to the user and
 * what recovery action to return to the SDK. For example, for an error indicating that credential input is wrong
 * (e.g wrong password), an implementation may display a prompt to the user that notifies them about the wrong
 * password and requests them to retry, and return a RetryAuthenticator recovery action. On the other hand, if the
 * error is a locked authenticator, the notification to the user may be a more intrusive alert and the recovery
 * action may be taking the user back to the authentication selection method (ChangeAuthenticator).
 *
 * The implementation may consult the defaultRecovery parameter to see what is the default recovery mode suggested
 * by the SDK.
 *
 * @param error Reported authentication error.
 * @param validRecoveries Allowed recovery responses, based on authentication session mode and context.
 * @param defaultRecovery Default recovery suggested by the SDK.
 * @return A promise object. On successful result, returns: AuthenticationErrorRecovery value describing which recovery action should be taken.
 */
promiseRecoveryForError(error: AuthenticationError, validRecoveries: Array<AuthenticationErrorRecovery>, defaultRecovery: AuthenticationErrorRecovery) : Promise<AuthenticationErrorRecovery>;

   /**
 * Collect input from the session. This function is invoked by the SDK when it wishes to collect input from the
 * authenticator UI. This will first be invoked right after startSession, and may then be invoked after subsequent
 * errors that were handled using Retry, when there's a need to register an expired authenticator after
 * registration, and for some authenticators -- when there's additional input needed to complete authentication even
 * after some input was provided (possibly after updating the session with data about the additional required
 * input).
 *
 * In addition to responding with input relevant to the authenticator (such as a PasswordInput for a
 * password authenticator), this method may asynchronously return a control request -- instructing the SDK to abort
 * or otherwise alter the authentication process. See ControlRequestType for a list of available request types.
 *
 * To accomodate both return options -- one for the authenticator input and one for control request -- the
 * declared return type of promiseInput() is InputOrControlResponse; see the documentation for that class for more
 * information on how it accomodates both types of return values.
 *
 * Implementations should asynchronously return input from this function as it becomes available. For example, a
 * password input session may drive a UI with a password input field and a submit button. Such an implementation
 * would then return the input password once the submit button is activated.
 * @return A promise object. On successful result, returns: InputOrControlResponse encoding either an authenticator input or a contorl request.
 */
promiseInput() : Promise<InputOrControlResponse<ResponseType>>;

   /**
 * End the authentication session.
 *
 * Implementations should update the UI to reflect the fact that the current authentication session is no longer
 * active; e.g by tearing down UI elements that were setup to collect input for this session.
 */
endSession() : void;
}
/**
 * Possible responses to authenticator fallback suggestion by the SDK.
 *
 */
export enum AuthenticatorFallbackAction {
       /** Change authentication method to a fallback authenticator as configured in the policy. */
   Fallback,
       /** Invoke the authentication method menu. */
   AuthMenu,
       /** Do not perform fallback; continue retrying the current authenticator. */
   Retry,
       /** Abort the authentication flow. */
   Cancel
}

/**
 * Denotes the type of an AuthenticatorSelectionResult object.
 *
 */
export enum AuthenticatorSelectionResultType {
       /** Authentication selection response denotes a request to select an authenticator */
   SelectAuthenticator,
       /** Authentication selection response denotes a request to abort authentication*/
   Abort,
       /** Authentication selection response denotes a request to escape the authentication action*/
   Escape
}

/**
 * The result of an authenticator selection request made by the SDK e.g UIHandler#selectAuthenticator. This can either
 * encode a selected authenticator, or a request to cancel the authentication.
 *
 */
export abstract class AuthenticatorSelectionResult { 

/**
 * General category of this selection result -- e.g abort vs. select an authenticator.
 */
   public getResultType() : AuthenticatorSelectionResultType;

/**
 * General category of this selection result -- e.g abort vs. select an authenticator.
 */
   public setResultType(resultType : AuthenticatorSelectionResultType) : void;

/**
 * Selected authenticator if resultType == AuthenticatorSelectionResultType#SelectAuthenticator
 */
   public getSelectedAuthenticator() : AuthenticatorDescription;

/**
 * Selected authenticator if resultType == AuthenticatorSelectionResultType#SelectAuthenticator
 */
   public setSelectedAuthenticator(selectedAuthenticator : AuthenticatorDescription) : void;

/**
 * Selected authentication parameters if resultType == AuthenticatorSelectionResultType#SelectAuthenticator
 */
   public getSelectedAuthenticationParameters() : Array<AuthenticationActionParameter>;

/**
 * Selected authentication parameters if resultType == AuthenticatorSelectionResultType#SelectAuthenticator
 */
   public setSelectedAuthenticationParameters(selectedAuthenticationParameters : Array<AuthenticationActionParameter>) : void;

/**
 * Selected escape option and paramaters
 */
   public getActionEscapeRequest() : ActionEscapeRequest;

/**
 * Selected escape option and paramaters
 */
   public setActionEscapeRequest(actionEscapeRequest : ActionEscapeRequest) : void;

/**
 * Create an AuthenticatorSelectionResult that encodes an abort request (resultType =
 * AuthenticatorSelectionResultType#Abort)
 */
   public static createAbortRequest() : AuthenticatorSelectionResult;

/**
 * Create an AuthenticatorSelectionResult that encodes a request to escape the action
 *
 * @param actionEscape The escape option to signal
 * @param escapeParams Additional parameters to pass to the journey when escaping.
 */
   public static createEscapeRequest(actionEscape: ActionEscapeOption, escapeParams: object | null) : AuthenticatorSelectionResult;

/**
 * Create an AuthenticatorSelectionResult that encodes an authenticator selection request (resultType =
 * AuthenticatorSelectionResultType#SelectAuthenticator, with the provided selected authenticator.)
 *
 * @param selectedAuthenticator The authenticator to be selected.
 *
 */
   public static createSelectionRequest(selectedAuthenticator: AuthenticatorDescription) : AuthenticatorSelectionResult;

/**
 * Create an AuthenticatorSelectionResult that encodes an authenticator selection request (resultType =
 * AuthenticatorSelectionResultType#SelectAuthenticator, with the provided selected authenticator.)
 *
 * @param selectedAuthenticator The authenticator to be selected.
 * @param parameters Authentication parameters to use for the authenticator
 *
 */
   public static createParameterizedSelectionRequest(selectedAuthenticator: AuthenticatorDescription, parameters: Array<AuthenticationActionParameter>) : AuthenticatorSelectionResult;
}
/**
 * Superclass for interface describing a single input step in a multi-step input authentication session; this
 * is passed to UIMultiInputAuthenticationSession#setInputStep to describe the current input step and may include
 * e.g a hint or instructions on the input to provide.
 *
 */
export interface MultiInputStepDescription { 

   /**
 * Tag for the current step.
 * This is an identification or name for the current step, allowing the application to distinguish between steps.
 */
getStepTag() : string;
}
/**
 * An interface for managing an authenticator UI session where multiple inputs are required during a successful session.
 * This is an exception of the UIAuthenticatorSession interface, with support multiple iterations of input.
 *
 * The session lifecycle for sessions implementing this interface is similar to the lifecycle for 'regular',
 * UIAuthenticatorSession-based sessions, with the exception that prior to each invoccation of promiseInput(), a call
 * to setInputStep is made to report to the session the information about the currently required input.
 *
 * For error recovery calls, a request for recovery via retry (AuthenticationErrorRecvoery#RetryAuthetnicator) will
 * in fact resume from the same step where an error has occurred and not restart the recovery.
 *
 */
export interface UIMultiInputAuthenticationSession<aResponseType extends InputResponseType,StepType extends MultiInputStepDescription> extends UIAuthenticatorSession<aResponseType> { 

   /**
 * Set the current input step. This is called before invocations of promiseInput to provide information about
 * the current input step.
 *
 * @param stepNumber The current, 0-based step number. This is incremented to reflect progress in the session.
 * @param maxStepNumber The number of steps in the session, if known in advance. If this is not known this is -1.
 * @param stepDescription An object describing the step, and possibly the input required for this step.
 */
setInputStep(stepNumber: number, maxStepNumber: number, stepDescription: StepType) : void;
}
/**
 * A password authenticator input response carrying an input password. This is an object returned from the authenticator UI
 * session for a password authenticator (UIAutneticatorSession) in response to a promiseInput call. When this object is returned,
 * the SDK will verify the password value it carries with the Transmit Server.
 *
 */
export abstract class PasswordInput extends InputResponseType { 

/**
 * Password submitted by the UI to the authenticator.
 */
   public getPassword() : string;

/**
 * Password submitted by the UI to the authenticator.
 */
   public setPassword(password : string) : void;

/**
 * Create a PasswordInput object with the specified password submission.
 *
 * @param password Initial value of the password attribute.
 */
   public static create(password: string) : PasswordInput;
}
/**
 * A set of services for conducting a TOTP code generation session. An implementation of this object is passed to the
 * application to allow it to start and stop the TOTP code generation process.
 *
 * After successful start, the TOTP codes passed to application may change; this will be done via a call to {@link UITotpGenerationSession#setTotpCode}.
 *
 */
export interface TotpGenerationSessionServices { 

/**
 * UIContext contains ui utils.
 */
   getUiContext() : UIContext;

   /**
 * When the application wishes to start displaying TOTP generated codes, it should invoke this method. This will construct a UITotpGenerationSession object
 * and make a series of invocation on that session. First, {@link UITotpGenerationSession#startSession} will be called. Soon after that, if the TOTP session
 * was constructed with a challengeBased flag enabled then {@link UITotpGenerationSession#promiseChallengeInput} will be invoked to acquire the challenge.
 * After this, the SDK will periodically invoke {@link UITotpGenerationSession#setTotpCode} with a generated TOTP code.
 */
startCodeGeneration() : void;

   /**
 * When the application wishes to end the generation of TOTP codes (e.g. the user closes the TOTP code display UI), it should invoke
 * this method. The SDK will invoke {@link UITotpGenerationSession#endSession} shortly after.
 */
finishSession() : void;
}
/**
 * A TOTP generator challenge input response carrying an input challenge. This is an object returned from the authenticator UI
 * session for a TOTP generation session (UITotpGenerationSession) in response to a promiseChallengeInput call. When this object is returned,
 * the SDK will use it for the generation of TOTP codes.
 *
 */
export abstract class TotpChallengeInput extends InputResponseType { 

/**
 * TOTP challenge submitted by the UI to the generation session.
 */
   public getChallenge() : string;

/**
 * TOTP challenge submitted by the UI to the generation session.
 */
   public setChallenge(challenge : string) : void;

/**
 * Create a TotpChallengeInput object with the specified challenge submission.
 *
 * @param challenge Initial value of the challenge attribute.
 */
   public static create(challenge: string) : TotpChallengeInput;
}
/**
 * An interface for managing a TOTP code generation UI session. When the SDK is required to ganerate TOTP codes in order to be used by the user
 * for TOTP authentication on another device or web page, it creates a TOTP code generation UI session, after the user has successfully authenticated using the
 * authenticator which was provisioned for TOTP code generation (on a previous authentication policy action, using the application-provided UIHandler. The
 * application then constructs an object implementing this interface, and the SDK invokes callbacks on this session
 * interface to manage the session lifecycle and interact with the application through the course of the TOTP code generation
 * session.
 *
 * Typically the TOTP code generation session ends when the application asks to end it. Regardless of whether the
 * application or the SDK terminate the TOTP code generation session, its endSession method is invoked.
 *
 * The session lifecycle always begins with a call to startSession, done by the SDK shortly after the session object
 * is created. With startSession the session receives the clientContext for the SDK operation invocation within
 * which the session is created. Also, the SDK passes a {@link TotpGenerationSessionServices} object to this session, which the
 * application can use to start the TOTP code generation process and in order to end the session.
 *
 * A TOTP code generation session consists of generating numerical codes according to parameters specified on the server side (such as
 * code length and ttl) and possibly a server generated challenge. If the method was configured to present a challenge, it will be
 * displayed on the authenticating device and this session is expected to acquire it on invocation of the
 * {@link UITotpGenerationSession#promiseChallengeInput()}. Post challenge acquisition or if method was not configured to
 * include a challenge the session services object will begin generating TOTP codes periodically. These codes are updated during the
 * session lifetime. When this happens, {@link #setTotpCode} is invoked by the SDK. Since each generated code is constrained by a TTL
 * specification, {@link #setTotpCode} is also invoked periodically, to update the application with the remaining time the current TOTP
 * code will be valid and until a new code will be generated. This happens after the application invokes the
 * {@link TotpGenerationSessionServices#startCodeGeneration}.
 *
 * When the application decides the TOTP code generation session is complete (e.g the user asked to close the TOTP code display UI), it
 * invokes the {@link TotpGenerationSessionServices#finishSession} callback. When either the SDK or the application decide
 * to finish the session, the SDK will invoke {@link UITotpGenerationSession#endSession()}.
 *
 */
export interface UITotpGenerationSession { 

   /**
 * Called to start the TOTP code generation session. This is invoked by the SDK shortly after the session is created.
 *
 * The implementation is expected to setup the UI and associate it with the clientContext, as well as keep a reference to the
 * totpGenerationSessionServices object to invoke it to perform operations related to the session.
 *
 * @param totpGenerationSessionServices An interface provided to the application for performing actions operations related to the session.
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked. This is optional since session may be invoked outside the scope of an action.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 */
startSession(totpGenerationSessionServices: TotpGenerationSessionServices, actionContext: PolicyAction | null, clientContext: object | null) : void;

   /**
 * Collect challenge input from the session. This function is invoked by the SDK when it wishes to collect challenge input
 * from the generation UI. If the TOTP session was constructed with a challengeBased flag enabled, then this will be invoked soon
 * after startSession, and may then be invoked after subsequent requests to Retry.
 *
 * In addition to responding with a challenge input relevant to the generation, this method may asynchronously return a
 * control request -- instructing the SDK to abort or otherwise alter the generation process.
 * See ControlRequestType for a list of available request types.
 *
 * To accomodate both return options -- one for the challenge input and one for control request -- the
 * declared return type of promiseChallengeInput() is InputOrControlResponse; see the documentation for that class for more
 * information on how it accomodates both types of return values.
 *
 * Implementations should asynchronously return challenge input from this function as it becomes available. For example, a
 * numeric challenge input session may drive a UI with a numeric challenge input field and a submit button. Such an implementation
 * would then return the numeric challenge input once the submit button is activated.
 * @return A promise object. On successful result, returns: InputOrControlResponse encoding either a challenge input or a contorl request.
 */
promiseChallengeInput() : Promise<InputOrControlResponse<TotpChallengeInput>>;

   /**
 * End the TOTP code generation session.
 *
 * Implementations should update the UI to reflect the fact that the current TOTP code generation session is no longer
 * active; e.g by tearing down UI elements that were setup to display output for this session.
 */
endSession() : void;

   /**
 * Invoked by the SDK when ever the TOTP code changes (according to the generation algorithm and prameters which were specified by the server
 * on provisioning). Also by the SDK periodically (usually every second) to indicate the remaining time interval until 'ttl' elapses and 'code' changes,
 * reflected by the 'remainingSeconds' argument.
 *
 * @param code The current generated TOTP code.
 * @param ttlSeconds The time interval in seconds in which this code is valid and until a new code is generated.
 * @param remainingSeconds The time in seconds until 'ttl' elapses and 'code' changes.
 */
setTotpCode(code: string, ttlSeconds: number, remainingSeconds: number) : void;

   /**
 * Optionally invoked (according to the configuration of the TOTP type/provider on the server) prior to the invocation of {@link #setTotpCode},
 * in order to give the application a chance to display this message to the user along with the generated code.
 */
setMessage(message: string) : void;
}
/**
 * The type or kind of the handle returned from {@link UserHandle}.
 */
export enum UserHandleType {
       /** The "username" used for authentication. E.g. "john.doe@domain.com" */
   UserId,
       /** A token provided by certain authentication journies on relevant server side configuration, to be used with relevant SDK APIs in place of a userId */
   IdToken
}

/**
 * An object holding a known (e.g. registered on this device) user information
 */
export interface UserInfo { 

/** An object holding a handle to be used as a user identification for the SDK APIs (e.g. {@link TransmitSDKXm#clearDataForUser}, {@link TransmitSDKXm#authenticate}) */
   getUserHandle() : string;

/** The type of user identification represented by the user handle {@link UserHandleType} for more details */
   getUserHandleType() : UserHandleType;

/** A "real" user name appropriate for UI presentation. E.g. "John Doe" or "john.doe@domain.com" when the former isn't provided */
   getDisplayName() : string;

/** Is the current device bound for the user */
   getDeviceBound() : boolean;

/** Has the user perfromed successful authentication on this device */
   getHasLoggedIn() : boolean;
}
/**
 * An interface representing a request to generate a TOTP code, encapsulating all parameters necessary for generation of the code,
 * e.g the generator to use for generation, a challenge to be provided to it, etc.
 * An object implementing this interface may be obtained by invoking {@link TransmitSDKXm#totpGenerationRequestForUserFromCanonicalString}
 * on a relevant string representation (e.g. produced by scanning a designated QR code).
 */
export interface TotpGenerationRequest { 

/**
 * The user identification handle {@link UserHandleType} for whom the TOTP session is to be invoked.
 */
   getUserId() : string;

/**
 * The user identification handle {@link UserHandleType} for whom the TOTP session is to be invoked.
 */
   setUserId(userId : string) : void;

/**
 * The type of user identification represented by the user handle {@link UserHandleType} for more details
 */
   getUserHandleType() : UserHandleType;

/**
 * The type of user identification represented by the user handle {@link UserHandleType} for more details
 */
   setUserHandleType(userHandleType : UserHandleType) : void;

/**
 * The challenge to be used by the SDK for a TOTP generation session
 */
   getChallenge() : string;

/**
 * The challenge to be used by the SDK for a TOTP generation session
 */
   setChallenge(challenge : string) : void;

/**
 * The generator id to be used by the SDK for a TOTP generation session
 */
   getGeneratorName() : string;

/**
 * The generator id to be used by the SDK for a TOTP generation session
 */
   setGeneratorName(generatorName : string) : void;
}
/**
 * A fingerprint authenticator input response carrying the prompt to show for fingerprint acquisition.  This is an
 * object returned from the authenticator UI session for a fingerprint authenticator (UIAutneticatorSession) in
 * response to a promiseInput call. When this object is returned, the SDK will start acquiring a fingerprint from
 * the user after displaying the prompt provided in this object.
 * Note that this is somewhat different than other authenticators where the return from promiseInput is the actual
 * authenticator secret to be verified whereas in this case the returned value encodes instructions for acquisition
 * done by the SDK.
 *
 */
export abstract class FingerprintInput extends InputResponseType { 

/**
 * Prompt message to display when acquiring the fingerprint.
 */
   public getPrompt() : string;

/**
 * Prompt message to display when acquiring the fingerprint.
 */
   public setPrompt(prompt : string) : void;

/**
 * Customized cancel button title to display in system biometric prompt.
 * Leave unset to use system default. Deployment availability is platform dependent.
 */
   public getCancelButtonTitle() : string;

/**
 * Customized cancel button title to display in system biometric prompt.
 * Leave unset to use system default. Deployment availability is platform dependent.
 */
   public setCancelButtonTitle(cancelButtonTitle : string) : void;

/**
 * Customized fallback button title to display in system biometric prompt.
 * Leave unset to disable fallback and hide button.
 */
   public getFallbackButtonTitle() : string;

/**
 * Customized fallback button title to display in system biometric prompt.
 * Leave unset to disable fallback and hide button.
 */
   public setFallbackButtonTitle(fallbackButtonTitle : string) : void;

/**
 * Control request to assign to system biometric prompt fallback button.
 * Clicking the fallback button (if enabled, see #fallbackButtonTItle) will behave as if
 * this control request was returned from promiseInput.
 * Default control request is ControlRequestType#SelectMethod.
 */
   public getFallbackControlRequestType() : ControlRequestType;

/**
 * Control request to assign to system biometric prompt fallback button.
 * Clicking the fallback button (if enabled, see #fallbackButtonTItle) will behave as if
 * this control request was returned from promiseInput.
 * Default control request is ControlRequestType#SelectMethod.
 */
   public setFallbackControlRequestType(fallbackControlRequestType : ControlRequestType) : void;

/**
 * Create a FingerprintInput object with a provided prompt. Fallback button will be hidden.
 *
 * @param prompt An initial value for the prompt attribute.
 */
   public static create(prompt: string | null) : FingerprintInput;

/**
 * Create a FingerprintInput object with a provided prompt and fallback button title and control request.
 * Fallback button is only available in the context of authentication and promotion actions.
 *
 * @param prompt An initial value for the prompt attribute.
 * @param fallbackButtonTitle An initial value for the fallbackButtonTitle attribute.
 * @param fallbackControlRequestType An initial value for the type of contorl request to associate with the fallback button.
 */
   public static createFallbackEnabledPrompt(prompt: string | null, fallbackButtonTitle: string | null, fallbackControlRequestType: ControlRequestType | null) : FingerprintInput;
}
/**
 * A face-id authenticator input response carrying the prompt to show for face ID acquisition.  This is an
 * object returned from the authenticator UI session for a native face (face-id) authenticator (UIAuthenticatorSession) in
 * response to a promiseInput call. When this object is returned, the SDK will start acquiring a face ID from
 * the user after displaying the prompt provided in this object.
 * Note that this is somewhat different than other authenticators where the return from promiseInput is the actual
 * authenticator secret to be verified whereas in this case the returned value encodes instructions for acquisition
 * done by the SDK.
 *
 */
export abstract class NativeFaceInput extends InputResponseType { 

/**
 * Prompt message to display when acquiring the face ID sample.
 */
   public getPrompt() : string;

/**
 * Prompt message to display when acquiring the face ID sample.
 */
   public setPrompt(prompt : string) : void;

/**
 * Customized cancel button title to display in system biometric prompt.
 * Leave unset to use system default. Deployment availability is platform dependent.
 */
   public getCancelButtonTitle() : string;

/**
 * Customized cancel button title to display in system biometric prompt.
 * Leave unset to use system default. Deployment availability is platform dependent.
 */
   public setCancelButtonTitle(cancelButtonTitle : string) : void;

/**
 * Customized fallback button title to display in system biometric prompt.
 * Leave unset to disable fallback and hide button.
 */
   public getFallbackButtonTitle() : string;

/**
 * Customized fallback button title to display in system biometric prompt.
 * Leave unset to disable fallback and hide button.
 */
   public setFallbackButtonTitle(fallbackButtonTitle : string) : void;

/**
 * Control request to assign to system biometric prompt fallback button.
 * Clicking the fallback button (if enabled, see #fallbackButtonTItle) will behave as if
 * this control request was returned from promiseInput.
 * Default control request is ControlRequestType#SelectMethod.
 */
   public getFallbackControlRequestType() : ControlRequestType;

/**
 * Control request to assign to system biometric prompt fallback button.
 * Clicking the fallback button (if enabled, see #fallbackButtonTItle) will behave as if
 * this control request was returned from promiseInput.
 * Default control request is ControlRequestType#SelectMethod.
 */
   public setFallbackControlRequestType(fallbackControlRequestType : ControlRequestType) : void;

/**
 * Create a NativeFaceInput object with a provided prompt. Fallback button will be hidden.
 *
 * @param prompt An initial value for the prompt attribute.
 */
   public static create(prompt: string | null) : NativeFaceInput;

/**
 * Create a NativeFaceInput object with a provided prompt and fallback button title and control request.
 * Fallback button is only available in the context of authentication and promotion actions.
 *
 * @param prompt An initial value for the prompt attribute.
 * @param fallbackButtonTitle An initial value for the fallbackButtonTitle attribute.
 * @param fallbackControlRequestType An initial value for the type of contorl request to associate with the fallback button.
 */
   public static createFallbackEnabledPrompt(prompt: string | null, fallbackButtonTitle: string | null, fallbackControlRequestType: ControlRequestType | null) : NativeFaceInput;
}
/**
 * A device biometrics input response carrying the textual attributes to display for device biometrics authenticator operation.  This is an
 * object returned from the authenticator UI session for a device biometrics authenticator (UIAuthenticatorSession) in
 * response to a promiseInput call. When this object is returned, the SDK will start operating the device biometrics authenticator.
 *
 * Note that this is somewhat different than other authenticators where the return from promiseInput is the actual
 * authenticator secret to be verified whereas in this case the returned value encodes instructions for acquisition
 * done by the SDK.
 *
 * The textual attributes actual deployment may be dependent and subject to specific platform or OS version availability.
 *
 */
export abstract class DeviceBiometricsInput extends InputResponseType { 

/**
 * Prompt message to display when running the device biometrics authenticator.
 */
   public getPrompt() : string;

/**
 * Prompt message to display when running the device biometrics authenticator.
 */
   public setPrompt(prompt : string) : void;

/**
 * Title text to display when running the device biometrics authenticator.
 */
   public getTitle() : string;

/**
 * Title text to display when running the device biometrics authenticator.
 */
   public setTitle(title : string) : void;

/**
 * Subtitle text to display when running the device biometrics authenticator.
 */
   public getSubtitle() : string;

/**
 * Subtitle text to display when running the device biometrics authenticator.
 */
   public setSubtitle(subtitle : string) : void;

/**
 * A cancel button title text to display when running the device biometrics authenticator.
 */
   public getCancelButtonTitle() : string;

/**
 * A cancel button title text to display when running the device biometrics authenticator.
 */
   public setCancelButtonTitle(cancelButtonTitle : string) : void;

/**
 * Create a DeviceBiometricsInput object with a provided prompt.
 *
 * @param prompt An initial value for the prompt attribute.
 */
   public static create(prompt: string | null) : DeviceBiometricsInput;

/**
 * Create a DeviceBiometricsInput object with the provided textual attributes.
 *
 * @param prompt An initial value for the prompt attribute.
 */
   public static createFull(title: string | null, subtitle: string | null, prompt: string | null, cancelButtonTitle: string | null) : DeviceBiometricsInput;
}
/**
 * A PIN authenticator input response carrying an input PIN. This is an object returned from the authenticator UI
 * session for a PIN authenticator (UIAutneticatorSession) in response to a promiseInput call. When this object is returned,
 * the SDK will verify the PIN value it carries with the Transmit Server.
 *
 */
export abstract class PinInput extends InputResponseType { 

/**
 * PIN submitted by the UI to the authenticator.
 */
   public getPin() : string;

/**
 * PIN submitted by the UI to the authenticator.
 */
   public setPin(pin : string) : void;

/**
 * Create a PinInput object with the specified PIN submission.
 *
 * @param pin Initial value of the pin attribute.
 */
   public static create(pin: string) : PinInput;
}
/**
 * A Pattern authenticator input response carrying an input pattern. This is an object returned from the authenticator UI
 * session for a pattern authenticator (UIAutneticatorSession) in response to a promiseInput call. When this object is returned,
 * the SDK will verify the pattern value it carries with the Transmit Server.
 *
 */
export abstract class PatternInput extends InputResponseType { 

/**
 * Pattern submitted by the UI to the authenticator.
 */
   public getPatternDescription() : string;

/**
 * Pattern submitted by the UI to the authenticator.
 */
   public setPatternDescription(patternDescription : string) : void;

/**
 * Create a PatternInput object with the specified pattern submission.
 *
 * @param patternDescription Value of the patternDescription attribute.
 */
   public static create(patternDescription: string) : PatternInput;
}
/**
 * A response for unregistration requests via UIHandler handleAuthenticatorUnregistration. This object represents the response sent from the client
 * to the SDK when asked to unregister an authenticator.
 *
 */
export abstract class UnregistrationInput { 

/**
 * An integer representing a user selection in the unregistration.
 * Value of "0" denotes "continue with unregistration" whereas a value of "1" denotes aborting the execution and policy.
 */
   public getUserChoice() : number;

/**
 * An integer representing a user selection in the unregistration.
 * Value of "0" denotes "continue with unregistration" whereas a value of "1" denotes aborting the execution and policy.
 */
   public setUserChoice(userChoice : number) : void;

/**
 * Create a UnregistrationInput object with a specified userChoice value.
 *
 * @param userChoice Initial value for the userChoice attribute.
 */
   public static create(userChoice: number) : UnregistrationInput;
}
/**
 * Top level superclass for placeholder authenticator input responses; this can either be a failure response
 * or a successful authenticator response.
 *
 */
export abstract class PlaceholderInputResponse extends InputResponseType { 

/**
 * Create a PlaceholderAuthSuccessResponse object with the specified placeholder token submission.
 *
 * @param placeholderToken Value of the placeholderToken attribute.
 */
   public static createSuccessResponse(placeholderToken: string) : PlaceholderInputResponse;

/**
 * Create a PlaceholderAuthFailureResponse object with the specified placeholder error information and updated authenticator status.
 * @param currentAuthenticatorStatus An AuthenticatorDescription object that holds the current status of the authenticator. This is where initial post-failure status will be taken from.
 * @param error An error describing the failure mode for the authentication.
 */
   public static createdFailedResponse(currentAuthenticatorStatus: AuthenticatorDescription, error: AuthenticationError) : PlaceholderInputResponse;

/**
 * Create a PlaceholderAuthFailureWithServerProvidedStatusResponse object with the specified placeholder error. Authenticator status will be updated according to server response.
 *
 * @param error An error describing the failure mode for the authentication.
 */
   public static createFailedResponseWithServerProvidedStatus(error: AuthenticationError) : PlaceholderInputResponse;
}
/**
 * Represents a successful authentication using placeholder authenticator
 *
 */
export class PlaceholderAuthSuccessResponse extends PlaceholderInputResponse { 

/**
 * Placeholder received from the Transmit Server (via the app server) to attest to successful external authentication.
 */
   public getPlaceholderToken() : string;

/**
 * Placeholder received from the Transmit Server (via the app server) to attest to successful external authentication.
 */
   public setPlaceholderToken(placeholderToken : string) : void;
}
/**
 * Represents a failed authentication using placeholder authenticator; encapsulates an error result with
 * an updated authenticator status.
 *
 */
export class PlaceholderAuthFailureResponse extends PlaceholderInputResponse { 

/**
 * An error representing the failure mode of the authenticator
 */
   public getFailureError() : AuthenticationError;

/**
 * An error representing the failure mode of the authenticator
 */
   public setFailureError(failureError : AuthenticationError) : void;

/**
 * Post failure status: true if the authenticator is expired (and will thus typically require registration after authentication).
 */
   public getExpired() : boolean;

/**
 * Post failure status: true if the authenticator is expired (and will thus typically require registration after authentication).
 */
   public setExpired(expired : boolean) : void;

/**
 * Post failure status: true if the authenticator is registered for the current user and app (registrationStatus == Registered)
 */
   public getRegistered() : boolean;

/**
 * Post failure status: true if the authenticator is registered for the current user and app (registrationStatus == Registered)
 */
   public setRegistered(registered : boolean) : void;

/**
 * Post failure status: Registration state of authenticator.
 */
   public getRegistrationStatus() : AuthenticatorRegistrationStatus;

/**
 * Post failure status: Registration state of authenticator.
 */
   public setRegistrationStatus(registrationStatus : AuthenticatorRegistrationStatus) : void;

/**
 * Post failure status: true if the authenticator is locked.
 */
   public getLocked() : boolean;

/**
 * Post failure status: true if the authenticator is locked.
 */
   public setLocked(locked : boolean) : void;
}
/**
 * Represents a failed authentication using placeholder authenticator where authenticator status is updated from server response;
 * encapsulates an error result.
 *
 */
export class PlaceholderAuthFailureWithServerProvidedStatusResponse extends PlaceholderInputResponse { 

/**
 * An error representing the failure mode of the authenticator
 */
   public getFailureError() : AuthenticationError;

/**
 * An error representing the failure mode of the authenticator
 */
   public setFailureError(failureError : AuthenticationError) : void;
}
/**
 * Represents a camera-based input response; this is essentiall a JSON representation
 * of a response to an image acquisition challenge.
 *
 */
export class CameraInputResponse extends InputResponseType { 

/**
 * JSON representation of the response to the acquisition challenge.
 */
   public getAcquisitionResponse() : object;

/**
 * JSON representation of the response to the acquisition challenge.
 */
   public setAcquisitionResponse(acquisitionResponse : object) : void;
}
/**
 * A single step in a multi-step camera acquisition session. This step description object includes
 * a set of acquisition challenges (CameraAcquisitionStepDescription#acquisitionChallenges).
 * The authentication input session must provide an acquisition response that meets one of these
 * challenges as the input for this step. This is done by passing the list of challenges to the
 * camera acquisition control for the platform.
 *
 */
export interface CameraAcquisitionStepDescription extends MultiInputStepDescription { 

/**
 * The acquisition instructions for the current acquisition step. This set of acuiqisition instructions
 * should be passed to the camera acquisition control for the platform to obtain the input for this
 * step.
 */
   getAcquisitionChallenges() : Array<object>;
}
/**
 * Represents a security question.
 */
export interface SecurityQuestion { 

/**
 * An identifier for the security question.
 */
   getSecurityQuestionId() : string;

/**
 * The text of the security question.
 */
   getSecurityQuestionText() : string;

/**
 * Was this question answered in previous registrations
 */
   getAnswered() : boolean;
}
export abstract class SecurityQuestionAnswer { 

   public getAnswerText() : string;

   public static createWithText(answerText: string) : SecurityQuestionAnswer;
}
export abstract class SecurityQuestionAndAnswer { 

   public getQuestion() : SecurityQuestion;

   public getAnswer() : SecurityQuestionAnswer;

   public getIsRemoved() : boolean;

/**
 * Provide an answer to a question
 */
   public static createAnswerToQuestion(question: SecurityQuestion, answer: SecurityQuestionAnswer) : SecurityQuestionAndAnswer;

/**
 * Request removing a question that was previously answered.
 */
   public static createAnswerRemovalRequest(question: SecurityQuestion) : SecurityQuestionAndAnswer;
}
/**
 * Represents a question-based authetnicator response type.
 * This is the superclass of the only-supported response type for the questions authetnicator,
 * SecurityQuestionAnswersInputResponse.
 */
export abstract class SecurityQuestionInputResponse extends InputResponseType { 

   public static createSecurityQuestionAnswersInputResponse(answers: Array<SecurityQuestionAndAnswer>) : SecurityQuestionInputResponse;
}
/**
 * An input response for a questions authetnicator.
 * Provides a set of answers to questions previosuly provided to the authenticator as part of the
 * current step descriptor.
 *
 * Note that only answers that are part of the current step may be provided.
 */
export class SecurityQuestionAnswersInputResponse extends SecurityQuestionInputResponse { 

   public getAnswers() : Array<SecurityQuestionAndAnswer>;
}
/**
 * A single step in a multi-step questions authenticator session. This step description object includes
 * a set questions that the user should answer to authenticate.
 *
 */
export interface SecurityQuestionStepDescription extends MultiInputStepDescription { 

/**
 * The set of questions to be answered by the user.
 */
   getSecurityQuestions() : Array<SecurityQuestion>;

/**
 * Minimum number of security questions desired in this step
 */
   getMinAnswersNeeded() : number;

/**
 * Minimum number of characters required for an answer in this step
 */
   getMinAnswerLength() : number;

/**
 * Maximum number of characters allowed for an answer in this step
 */
   getMaxAnswerLength() : number;
}
/**
 * Represents an audio-based input response; this is essentiall a JSON representation
 * of a response to an audio acquisition challenge.
 *
 */
export class AudioInputResponse extends InputResponseType { 

/**
 * JSON representation of the response to the acquisition challenge.
 */
   public getAcquisitionResponse() : object;

/**
 * JSON representation of the response to the acquisition challenge.
 */
   public setAcquisitionResponse(acquisitionResponse : object) : void;
}
/**
 * A single step in a multi-step audio acquisition session. This step description object includes
 * a set of acquisition challenges (AudioAcquisitionStepDescription#acquisitionChallenges).
 * The authentication input session must provide an acquisition response that meets one of these
 * challenges as the input for this step. This is done by passing the list of challenges to the
 * audio acquisition control for the platform.
 *
 */
export interface AudioAcquisitionStepDescription extends MultiInputStepDescription { 

/**
 * The acquisition instructions for the current acquisition step. This set of acuiqisition instructions
 * should be passed to the audio acquisition control for the platform to obtain the input for this
 * step.
 */
   getAcquisitionChallenges() : Array<object>;

/**
 * Passphrase text -- for speaking by the user in this step.
 */
   getPassphraseText() : string;
}
/**
 * Represents a target -- device / channel / combination thereof -- that should be
 * used with a target-based authenticator.
 *
 * This is a base interface; specific targets for specific authenticators are
 * derived from this interface.
 */
export interface AuthenticatorTarget { 

/**
 * User-facing description of the target.
 */
   getDescription() : string;
}
/**
 * An authentication action parameter selecting a target for target-based authenticators.
 *
 * When a parameter of this type is used in an authentication action, it will set the target
 * for use by the target-based authenticator. At most one parameter of this type may be specified
 * for an authentication action.
 *
 * Typically if this parameter is not specified and there is more than one target available for a selected
 * authenticator, the authenticator session will have to select the target (e.g by asking the user for a target).
 *
 */
export abstract class AuthenticationActionParameterTargetSelection extends AuthenticationActionParameter { 

/**
 * The authenticator target for selection for this authentication action.
 */
   public getTarget() : AuthenticatorTarget;

/**
 * Construct an authentication action target selection parameter for selecting a specified target.
 *
 * @param target the target value for the constructed object.
 */
   public static create(target: AuthenticatorTarget) : AuthenticationActionParameterTargetSelection;
}
/**
 * The input type for all target-based authenticators' authenticator input response. This object
 * represents either a target selection request, or an input response. Two type parameters are defined
 * for this type -- the ConcreteAuthenticatorInputType is the class of input responses that may be
 * carried by it and the TargetType is the type of target carried by target selection requests.
 * All UIAuthenticatorSessionTargetBased-based sessions use a response type which is a specialization
 * of this generic type, with a specific ConcreateAuthenticatorInputType and TargetType types.
 *
 * A UIAuthenticatorSessionTargetBased-based session returns an instance of this class created by
 * #createTargetSelectionRequest to indicate a request to change the target from promiseInput.
 *
 * A UIAuthenticatorSessionTargetBased-based session returns an instance of this class created by
 * #createAuthenticatorInput to provide concrete authenticator input response to promiseInput.
 */
export abstract class TargetBasedAuthenticatorInput<ConcreteAuthenticatorInputType extends InputResponseType,TargetType extends AuthenticatorTarget> extends InputResponseType { 

/**
 * Indicates a concrete authenticator input. Can't contain a non-null value if #selectedTarget contains a
 * non-null value.
 */
   public getAuthenticatorInput() : ConcreteAuthenticatorInputType;

/**
 * Indicates a concrete authenticator input. Can't contain a non-null value if #selectedTarget contains a
 * non-null value.
 */
   public setAuthenticatorInput(authenticatorInput : ConcreteAuthenticatorInputType) : void;

/**
 * Indicates selected targets.  Can't contain a non-null value if #authenticatorInput contains a
 * non-null value.
 */
   public getSelectedTargets() : Array<TargetType>;

/**
 * Indicates selected targets.  Can't contain a non-null value if #authenticatorInput contains a
 * non-null value.
 */
   public setSelectedTargets(selectedTargets : Array<TargetType>) : void;

/**
 * Construct a target-based authenticator input conveying a concrete input for the
 * concrete authenticator type.
 *
 * @param authenticatorInput The concrete input for the concrete authenticator type.
 */
   public static createAuthenticatorInput<ConcreteAuthenticatorInputType extends InputResponseType, TargetType extends AuthenticatorTarget>(authenticatorInput: ConcreteAuthenticatorInputType) : TargetBasedAuthenticatorInput<ConcreteAuthenticatorInputType,TargetType>;

/**
 * Construct a target-based authenticator input conveying a request to change the authenticator
 * target with a single target selection. Note: Maintained for backwards compatibility.
 *
 * @param target The target to select.
 */
   public static createTargetSelectionRequest<ConcreteAuthenticatorInputType extends InputResponseType, TargetType extends AuthenticatorTarget>(target: TargetType) : TargetBasedAuthenticatorInput<ConcreteAuthenticatorInputType,TargetType>;

/**
 * Construct a target-based authenticator input conveying a request to change the authenticator
 * target with multiple target selection.
 *
 * @param targets The targets to select.
 */
   public static createTargetsSelectionRequest<ConcreteAuthenticatorInputType extends InputResponseType, TargetType extends AuthenticatorTarget>(targets: Array<TargetType>) : TargetBasedAuthenticatorInput<ConcreteAuthenticatorInputType,TargetType>;
}
/**
 * Base interface for all target-based authenticator sessions.
 *
 * Target-based authenticators involve using an OOB channel or device during the authentication process. For example,
 * an OTP authenticator allows selecting how the OTP will be delivered (and where to). Similarly a mobile approve
 * authenticator allows selecting which device(s) should be used for approval.
 *
 * These authenticators' input response is always a specialization of TargetBasedAuthenticatorInput. The specialization
 * specifies a type for concrete inputs to the authenticator as well as the type for authentiactor targets.
 *
 * These authenticators allow selecting the target to use among a list of targets; this is done by
 * #promiseInput method returning an instance of #TargetBasedAuthenticatorInput created by a call to
 * TargetBasedAuthenticatorInput#createTargetSelectionRequest, with the selected
 * target. The list of available targets for selection is provided to the session via a call to setAvailableTargets
 * that always precedes promiseInput if there's a change to the set of available targets (and specifically prior to
 * the first invocation of promiseInput).
 *
 * To provide actual input to the authenticator, as opposed to a request to change the target, the #promiseInput
 * method returns an instance of #TargetBasedAuthenticatorInput created by a call to
 * TargetBasedAuthenticatorInput#createAuthenticatorInput, with the desired input response instance.
 *
 * Target-based authenticators allow specifying at most one parameter of type
 * AuthenticationActionParameterTargetSelection when starting the authentication action (e.g using
 * selectAuthenticator). When such a parameter is provided and it identifies a valid target, this target will be
 * initially used for authentication.
 */
export interface UIAuthenticatorSessionTargetBased<MResponseType extends InputResponseType,TargetType extends AuthenticatorTarget> extends UIAuthenticatorSession<TargetBasedAuthenticatorInput<MResponseType,TargetType>> { 

   /**
 * Notify the session of the list of targets available for authentication.
 * This is invoked by the SDK prior to #promiseInput whenever there's an update to the set of available targets,
 * and prior to the first invocation of #promiseInput to provide the initial list of targets.
 *
 * @param targets List of targets available for this session.
 */
setAvailableTargets(targets: Array<TargetType> | null) : void;
}
/**
 * Represents the type of an OTP channel.
 *
 */
export enum OtpChannel {
       /** An unknown channel type */
   Unknown,
       /** SMS based OTP delivery */
   Sms,
       /** E-mail based OTP delivery */
   Email,
       /** Delivery via a push notification */
   PushNotification,
       /** Delivery via a voice telephone call */
   VoiceCall
}

/**
 * Represents target device info for selection, may be used for mobile approve, OTP push or TOTP.
 *
 */
export interface TargetDeviceDetails { 

/**
 * Target device id
 */
   getDeviceId() : string;

/**
 * Target device model
 */
   getModel() : string;

/**
 * Target device last access date
 */
   getLastAccessed() : number;

/**
 * Is target device also current device
 */
   getIsCurrent() : boolean;

/**
 * Target device os model
 */
   getOsType() : string;

/**
 * Target device os version
 */
   getOsVersion() : string;

/**
 * Target device alias
 */
   getAlias() : string | null;

   /**
 * Creates a description string for this device
 */
describe() : string;
}
/**
 * Represents an OTP target, to which an OTP code may be generated and sent.
 *
 */
export interface OtpTarget extends AuthenticatorTarget { 

/**
 * Type of channel for this OTP target.
 */
   getChannel() : OtpChannel;

/**
 * Optional device attributes if a target designates a device
 */
   getDeviceDetails() : TargetDeviceDetails | null;
}
/**
 * A supertype for all OTP concrete authenticator inputs.
 *
 */
export class OtpInput extends InputResponseType { 
}
/**
 * An OTP authenticator input response carrying a request to resent an OTP code. This is an object
 * returned from the authenticator UI session for an OTP (UIAutneticatorSessionOtp) in response to a promiseInput
 * call. When this object is returned, the SDK will trigger generation of an OTP code to the last selected target.
 * The SDK will then invoke the session's UIAuthenticatorSession#promiseInput again to receive further inputs from the
 * authenticator session (e.g an OtpInputOtpSubmission object). Also, once the new OTP code is generated, the SDK will
 * invoke the session's UIAuthenticatorSessionOtp#setGeneratedOtp.
 *
 */
export abstract class OtpInputRequestResend extends OtpInput { 

/**
 * Create an OtpInputRequestResend object.
 */
   public static createOtpResendRequest() : OtpInputRequestResend;
}
/**
 * An OTP authenticator input response carrying an input OTP. This is an object returned from the authenticator UI
 * session for an OTP (UIAutneticatorSessionOtp) in response to a promiseInput call. When this object is returned,
 * the SDK will verify the OTP value it carries with the Transmit Server. This object is to be returned by the session
 * only after at least one OTP was generated either through auto exec or by providing an OtpInputSelectTarget
 * response.
 *
 */
export abstract class OtpInputOtpSubmission extends OtpInput { 

/**
 * OTP value submitted by the UI to the authenticator.
 */
   public getOtp() : string;

/**
 * OTP value submitted by the UI to the authenticator.
 */
   public setOtp(otp : string) : void;

/**
 * Create an OtpInputOtpSubmission with the specified OTP value.
 *
 * @param otp Initial value for the otp property.
 */
   public static createOtpSubmission(otp: string) : OtpInputOtpSubmission;
}
/**
 * Represents the format of a generated OTP. This is an abstract base for concrete
 * OtpFormat types.
 *
 */
export interface OtpFormat { 
}
/**
 * Represents an OTP Format that describes a numeric OTP, comprising of a fixed
 * number of digits.
 *
 */
export interface OtpFormatNumeric extends OtpFormat { 

/**
 * Number of digits in the generated OTP
 */
   getOtpLength() : number;
}
/**
 * Represents an OTP Format that describes a QR OTP.
 *
 */
export interface OtpFormatQr extends OtpFormat { 
}
/**
 * Represents an OTP Format that describes an externally defined OTP format.
 * This includes a single JSON object that may include additional OTP format parameters.
 *
 */
export interface OtpFormatExternal extends OtpFormat { 

   getData() : object;
}
/**
 * Superclass for push request payloads comprehensible by the TransmitSDK. These are
 * payloads sent via push notifications that instruct the SDK to perform some action (e.g
 * display mobile approvals).
 *
 */
export abstract class PushRequestPayload { 

   /**
 * Return the semantic title content the push notification should display.
 */
public abstract title() : string;
}
/**
 * A push request payload that holds the code for an OTP based authentication. Objects
 * of this class encode parameters for showing the OTP code. Typically they are
 * created based on data sent via a push notification, and used by the application to display a push notification.
 *
 */
export abstract class OtpPushRequestPayload extends PushRequestPayload { 

   /**
 * Return the user ID specified by this mobile approve push request payload, if any.
 */
public abstract userId() : string;

   /**
 * Return the semantic body content the push notification should display.
 */
public abstract body() : string;
}
/**
 * An authenticator UI session for OTP. This interface, implemented by the client, is a specialization of the
 * UIAuthenticatorSessionTargetBased protocol used for OTP authentication. In addition to the protocol defined by
 * UIAuthenticatorSessionTargetBased, this interface provides facilities for the SDK to notify the UI session that an OTP
 * was generated, along with information on the target to which the OTP was sent and the format of the OTP.
 *
 * The valid inputs from a UIAuthenticatorSessionOtp's promiseInput call are classes derived from #OtpInput or
 * #TargetBasedAuthenticatorInputSelectTarget.
 *
 */
export interface UIAuthenticatorSessionOtp extends UIAuthenticatorSessionTargetBased<OtpInput,OtpTarget> { 

   /**
 * Notify the session that an OTP was generated with a specific format and target. This notification is sent
 * every time the client returns an OtpInputRequestResend or TargetBasedAuthenticatorInputSelectTarget response in
 * a call to promiseInput(), once the new OTP code was sent. In addition if an OTP code was automatically generated
 * when action execution began, details of this automatically generated code will be relayed using this call
 * once the session starts (note that when the session is created, UIHandler#createOtpAuthSession is called
 * with parameters that reflect that as well).
 *
 * This is also invoked by the SDK with a null \ref format and \ref target to indicate that there is no valid OTP
 * generated and pending validation. If that is the case, an implementation should select a valid OTP target in the
 * next call to promiseInput.
 *
 * Implementations should update the UI to reflect the newly generated OTP format and the target to which the
 * OTP was sent.
 *
 * @param format Format of the generated OTP
 * @param target OtpTarget describing the target to which the OTP was sent.
 *
 */
setGeneratedOtp(format: OtpFormat | null, target: OtpTarget | null) : void;
}
/**
 * A supertype for all Mobile Approve authenticator inputs.
 *
 */
export class MobileApproveInput extends InputResponseType { 
}
/**
 * Represents a Mobile Approve target, for which an approval may be created.
 *
 */
export interface MobileApproveTarget extends AuthenticatorTarget { 

/**
 * Target device details.
 */
   getDeviceDetails() : TargetDeviceDetails;
}
/**
 * A Mobile Approve authenticator input response carrying a request to poll for authentication. This is an object
 * returned from the authenticator UI session for a MobileApprove (UIAutneticatorSessionMobileApprove) in response to
 * a promiseInput call. When this object is returned, the SDK will poll the server asking if authentication was
 * completed and what was the result. This object is to be returned by the session only after approval was created
 * either through auto exec or by providing an MobileApproveTargetSelectionInput response.
 *
 * There are two types of polling requests: long polling and short polling. A short polling request issues a request
 * to the server that returns immediately, either indicating that the mobile approve was approved or denied, or indicating
 * the approval is still pending (in which case the session isn't complete and promiseInput will be invoked again).
 * Clients should request the SDK for short polling requests periodically (eg. once every 3 seconds). To do this,
 * a client would typically create a timer in a call to UIAuthenticatorSessionMobileApprove#promiseInput, such that
 * promiseInput will return the polling request asynchronously after that period. With a polling period of P it may
 * take up to period P to detect that an approval was confirmed / denied (or on average P/2).
 *
 * A long polling request indicates to the server that it should return a response as soon as an approval is no longer pending
 * -- or after a timeout occurs (the timeout is configurable in the long polling request). Here a client would typically issue the
 * long polling request immediately on invocation of UIAuthenticatorSessionMobileApprove#promiseInput, specifiying a timeout
 * period P. If ater period P the approval is still pending, promiseInput will be invoked again (and will probably return the same
 * long polling request.)
 *
 */
export abstract class MobileApproveInputRequestPolling extends MobileApproveInput { 

/**
 * If nonzero -- timeout in seconds for long polling request to issue.
 * If zero -- this is a short poll request.
 */
   public getPollingTimeout() : number;

/**
 * If nonzero -- timeout in seconds for long polling request to issue.
 * If zero -- this is a short poll request.
 */
   public setPollingTimeout(pollingTimeout : number) : void;

/**
 * Create a MobileApproveInputRequestPolling object representing a short polling request.
 */
   public static createRequestPollingInput() : MobileApproveInputRequestPolling;

/**
 * Create a MobileApproveInputRequestPolling object representing a long polling request, with
 * given timeout.
 */
   public static createRequestLongPollingInput(timeoutInSeconds: number) : MobileApproveInputRequestPolling;
}
/**
 * Represents the an OTP generated for mobile approval.
 *
 */
export interface MobileApproveOtp { 

   getValue() : string;

   getFormat() : OtpFormat;

   getQrAlternativeRepresentation() : string | null;
}
/**
 * An authenticator UI session for Mobile Approve. This interface, implemented by the client, is a
 * specialization of the UIAuthenticatorSessionTargetBased protocol used for Mobile Approve authentication. In
 * addition to the protocol defined by UIAuthenticatorSessionTargetBased, this interface provides facilities
 * for the SDK to notify the UI session that an approval was created, along with information on the target for
 * which the approval was created.
 *
 */
export interface UIAuthenticatorSessionMobileApprove extends UIAuthenticatorSessionTargetBased<MobileApproveInput,MobileApproveTarget> { 

   /**
 * Notify the session that an approval was created for target. This notification is sent when the client returns
 * a MobileApproveTargetSelectionInput response in a call to promiseInput(), as soon as the new approval was
 * created. In addition if an approval was automatically created when action execution began, details of this
 * automatically created approval will be relayed using this call once the session starts (note that when the
 * session is created, UIHandler#createMobileApproveAuthSession is called with parameters that reflect that as
 * well).
 *
 * Implementations should update the UI to reflect the newly created approval and the target for which the
 * approval was created. If otp was generated for the approval the generated otp and format will be transferred
 * here as well.
 *
 * Calling this with null targets notifies the session that it should reset it's state to allow retry of the
 * authentication process. This should include cleaning up of targets and possibly otp, resetting the state of
 * the session to inital state.
 *
 * @param targets the targets for which the approval was created.
 *
 */
setCreatedApprovalInfo(targets: Array<MobileApproveTarget> | null, otp: MobileApproveOtp | null) : void;
}
/**
 * Represents the format of a TOTP challenge. This is an abstract base for concrete TotpChallengeFormat types.
 *
 */
export interface TotpChallengeFormat { 
}
/**
 * Represents a TOTP challenge format that describes an alpha-numeric readable TOTP challenge.
 *
 */
export interface TotpChallengeFormatAlphaNumeric extends TotpChallengeFormat { 
}
/**
 * Represents a TOTP challenge format that describes a numeric TOTP challenge.
 *
 */
export interface TotpChallengeFormatNumeric extends TotpChallengeFormat { 
}
/**
 * Represents a TOTP challenge format that describes a QR TOTP challenge.
 *
 */
export interface TotpChallengeFormatQr extends TotpChallengeFormat { 
}
/**
 * Represents a TOTP challenge with value and format.
 *
 */
export class TotpChallenge { 

/**
 * Challenge value.
 */
   public getValue() : string;

/**
 * Challenge value.
 */
   public setValue(value : string) : void;

/**
 * Challenge format.
 */
   public getFormat() : TotpChallengeFormat;

/**
 * Challenge format.
 */
   public setFormat(format : TotpChallengeFormat) : void;
}
/**
 * Represents a Totp target, on which an temporary code may be generated.
 *
 */
export interface TotpTarget extends AuthenticatorTarget { 

/**
 * Target device details.
 */
   getDeviceDetails() : TargetDeviceDetails;
}
/**
 * A supertype for all Totp authenticator inputs.
 *
 */
export class TotpInput extends InputResponseType { 
}
/**
 * A Totp authenticator input response carrying an input code. This is an object returned from the authenticator UI
 * session for an Totp (UIAutneticatorSessionTotp) in response to a promiseInput call. When this object is returned,
 * the SDK will verify the Totp value it carries with the Transmit Server.
 *
 */
export abstract class TotpInputCodeSubmission extends TotpInput { 

/**
 * Totp value submitted by the UI to the authenticator.
 */
   public getCode() : string;

/**
 * Totp value submitted by the UI to the authenticator.
 */
   public setCode(code : string) : void;

/**
 * Create an TotpInputCodeSubmission with the specified code value.
 *
 * @param code the code value for the Totp.
 */
   public static createTotpCodeSubmission(code: string) : TotpInputCodeSubmission;
}
/**
 * An authenticator UI session for Totp. This interface, implemented by the client, is a specialization of the
 * UIAuthenticatorSessionTargetBased protocol used for Totp authentication. In addition to the protocol defined
 * by UIAuthenticatorSessionTargetBased, this interface provides facilities for the SDK to notify the UI session
 * that a target device(s) was selected for code generation.
 *
 * The interface also provides a method setChallenge to be used to update the UI session of a created challenge.
 * The UI session is then expected to display the challenge to the user on current device. The challenge is
 * expected to then be acquired by the code generating device.
 *
 * UIAuthenticatorSessionTargetBased.setAvailableTargets is called with null to indicate there's no need for target
 * selection. In such a case the UI Session is expected to move directly to display challenge (if needed) and TOTP
 * code input.
 *
 */
export interface UIAuthenticatorSessionTotp extends UIAuthenticatorSessionTargetBased<TotpInput,TotpTarget> { 

   /**
 * Notify the session that a target device(s) was selected for code generation. This notification is sent when the
 * client returns a TotpTargetSelectionInput response in a call to promiseInput().
 *
 * Implementations should update the UI to reflect the target on which the code may be generated.
 *
 * @param targets the targets for which the approval was created.
 *
 */
setTargetDevices(targets: Array<TotpTarget> | null) : void;

   /**
 * Notify the session that a challenge was created for code generation. This notification is sent if the server created
 * a challenge to be used in TOTP code generation, soon after startSession was called.
 *
 * Implementations should update the UI to display the challenge so that it can be acquired by generating the code
 * generating device.
 *
 * @param challenge The challenge created by the server for this code generation.
 */
setChallenge(challenge: TotpChallenge | null) : void;
}
/**
 * Top level superclass for FIDO2 authenticator input responses; this can either be a failure response
 * or a successful authenticator response.
 *
 */
export abstract class Fido2InputResponse extends InputResponseType { 

/**
 * Display name submitted by the UI to the authenticator.
 */
   public getDisplayName() : string;

/**
 * Display name submitted by the UI to the authenticator.
 */
   public setDisplayName(displayName : string) : void;

/**
 * Create a Fido2InputResponse object with the specified display name submission.
 *
 * @param displayName Initial value of the display name attribute.
 */
   public static create(displayName: string) : Fido2InputResponse;
}
/**
 * A response to a confirmation or information screen. This object represents the response sent from the client
 * to the SDK when asked to display a confirmation or information screen.
 *
 */
export abstract class ConfirmationInput { 

/**
 * An integer representing a user selection in the confirmation or information screen. The exact semantics of this
 * value depends on the context in which the ConfirmationInput object is returned. For example, for a confirmation
 * screen a value of "0" denotes "continue" whereas a value of "1" denotes "cancel"; these values are returned
 * to the policy evaluation engine for use in the policy downstream.
 */
   public getUserChoice() : number;

/**
 * An integer representing a user selection in the confirmation or information screen. The exact semantics of this
 * value depends on the context in which the ConfirmationInput object is returned. For example, for a confirmation
 * screen a value of "0" denotes "continue" whereas a value of "1" denotes "cancel"; these values are returned
 * to the policy evaluation engine for use in the policy downstream.
 */
   public setUserChoice(userChoice : number) : void;

/**
 * An escape request, if this object is signalling a request to invoke an escape path in the journey.
 */
   public getActionEscapeRequest() : ActionEscapeRequest;

/**
 * An escape request, if this object is signalling a request to invoke an escape path in the journey.
 */
   public setActionEscapeRequest(actionEscapeRequest : ActionEscapeRequest) : void;

/**
 * Create a ConfirmationInput object with a specified userChoice value.
 *
 * @param userChoice Initial value for the userChoice attribute.
 */
   public static create(userChoice: number) : ConfirmationInput;

/**
 * Create an ConfirmationInput that encodes a request to escape the action
 *
 * @param actionEscape The escape option to signal
 * @param escapeParams Additional parameters to pass to the journey when escaping.
 */
   public static createEscapeRequest(actionEscape: ActionEscapeOption, escapeParams: object | null) : ConfirmationInput;
}
export enum QrCodeFormat {
       /** Numeric data */
   Numeric,
       /** Alphanumeric data */
   Alphanumeric,
       /** Binary data */
   Binary
}

/**
 * Represents a qr code result.
 */
export abstract class QrCodeResult { 

   public getQrCode() : string;

   public getQrCodeFormat() : QrCodeFormat;

   public static createQrCodeResult(qrCode: string, qrCodeFormat: QrCodeFormat) : QrCodeResult;
}
/**
 * A response to scan qr code action. The object represents the response sent from the client
 * to the SDK when asked to display a scan qr code screen.
 *
 */
export abstract class ScanQrCodeInput extends InputResponseType { 

/**
 * An object representing scanned qr code.
 */
   public getQrCodeResult() : QrCodeResult;

/**
 * An object representing scanned qr code.
 */
   public setQrCodeResult(qrCodeResult : QrCodeResult) : void;

/**
 * Create a ScanQrCodeInput object with a specified qr code value.
 *
 * @param qrCodeResult Initial value for the qrCodeResult attribute.
 */
   public static createScanQrCodeInput(qrCodeResult: QrCodeResult) : ScanQrCodeInput;
}
/**
 * The result of a JSON processing callback. This object is returned by a client implementation of UIHandler in
 * response to an SDK request to process JSON data as part of handling of a JSON Data action.
 * The object encodes a selection whether policy processing should continue or abort -- allowing JSON processing
 * code to halt policy evaluation.
 *
 */
export abstract class JsonDataProcessingResult { 

/**
 * Indicates whether policy execution should continue. When set to true -- policy execution will continue after this
 * JsonDataProcessingResult is returned to the SDK. When set to false -- policy execution will abort at that time,
 * with a AuthenticationErrorCode#UserCanceled code.
 */
   public getContinueProcessing() : boolean;

/**
 * Indicates whether policy execution should continue. When set to true -- policy execution will continue after this
 * JsonDataProcessingResult is returned to the SDK. When set to false -- policy execution will abort at that time,
 * with a AuthenticationErrorCode#UserCanceled code.
 */
   public setContinueProcessing(continueProcessing : boolean) : void;

/**
 * Create a JsonDataProcessingResult.
 *
 * @param continueProcessing Initial value for the continueProcessing attribute.
 */
   public static create(continueProcessing: boolean) : JsonDataProcessingResult;
}
/**
 * Type of redirect handling response. Defines how the multi-policy flow should be continue after current
 * policy completion and having a redirection to another policy.
 *
 */
export enum RedirectResponseType {
       /** Continue to redirection target policy */
   RedirectToPolicy,
       /** Quit at current policy without proceeding to next policy */
   CancelRedirect
}

/**
 * A response to a redirect handling request. This object represents the response sent from the client
 * to the SDK when asked to confirm redirect, complete without redirect or abort with error.
 *
 */
export abstract class RedirectInput { 

/**
 * The response type, if this object represents a control request.
 */
   public getRedirectResponse() : RedirectResponseType;

/**
 * The response type, if this object represents a control request.
 */
   public setRedirectResponse(redirectResponse : RedirectResponseType) : void;

/**
 * Optional additional parameters to use instead of those provided in the server request.
 */
   public getAdditionalParametersOverride() : object | null;

/**
 * Optional additional parameters to use instead of those provided in the server request.
 */
   public setAdditionalParametersOverride(additionalParametersOverride : object | null) : void;

/**
 * Create a RedirectInput object with a specified redirectResponse value.
 *
 * @param redirectResponse Initial value for the redirectResponse attribute.
 */
   public static create(redirectResponse: RedirectResponseType) : RedirectInput;
}
/**
 * Type of redirect by policy invocation options in SDK API. See uiHandler#handlePolicyRedirect use case.
 */
export enum RedirectType {
       /** Next policy device bind policy - TransmitSDKXm#bind*/
   RedirectTypeBind,
       /** Next policy is a session starting policy invoked with TransmitSDKXm#authenticate */
   RedirectTypeAuthenticate,
       /** Next policy is a session starting policy invoked with TransmitSDKXm#bind or TransmitSDKXm#authenticate according to device state. */
   RedirectTypeBindOrAuthenticate,
       /** Next policy is of general form invoked with TransmitSDKXm#invokePolicy */
   RedirectTypeInvokePolicy
}

/**
 * Represents the type of #FormInput control request, as input from a form
 * session's promiseInput call. */
export enum FormControlRequest {
       /** This is a request to submit the jsonData attribute for the form. */
   Submit,
       /** This is a request to abort the policy executing the form action. */
   Abort,
       /** This is a request to escape the form action. */
   Escape
}

/**
 * A form input response carrying a JSON or a cancellation request.
 * When this object is returned via promiseFormInput#complete() the SDK will assert the next step of the form or
 * abort the current action.
 */
export abstract class FormInput { 

/**
 Json provided by the the UI to the form.
 */
   public getJsonData() : object;

/**
 Json provided by the the UI to the form.
 */
   public setJsonData(jsonData : object) : void;

/**
 * Input type -- indicates whether this is an abort request, or a submit request.
 */
   public getControlRequest() : FormControlRequest;

/**
 * Input type -- indicates whether this is an abort request, or a submit request.
 */
   public setControlRequest(controlRequest : FormControlRequest) : void;

/**
 * An escape request, if this object is signalling a request to invoke an escape path in the journey.
 */
   public getActionEscapeRequest() : ActionEscapeRequest;

/**
 * An escape request, if this object is signalling a request to invoke an escape path in the journey.
 */
   public setActionEscapeRequest(actionEscapeRequest : ActionEscapeRequest) : void;

/**
 * Create a FormInput with a Submit control request, and the provided submission data.
 *
 * @param jsonData Initial value for the jsonData attribute.
 */
   public static createFormInputSubmissionRequest(jsonData: object) : FormInput;

/**
 * Create a FormInput with an Abort control request
 */
   public static createFormCancellationRequest() : FormInput;

/**
 * Create a FormInput that encodes a request to escape the action
 *
 * @param actionEscape The escape option to signal
 * @param escapeParams Additional parameters to pass to the journey when escaping.
 */
   public static createEscapeRequest(actionEscape: ActionEscapeOption, escapeParams: object | null) : FormInput;
}
/**
 * An interface for managing an form UI session. When the SDK needs to show form, it first creates an
 * form UI session using the application-provided UIHandler. The application then constructs an object implementing
 * this interface, and the SDK invokes callback on this session interface to manage the session lifecycle and
 * interact with the application through the course of the form session.
 *
 * Form session ends when the SDK asks to end it.
 *
 * The session lifecycle always begins with a call to startSession, done by the SDK shortly after the session object
 * is created. With startSession the session receives the clientContext for the SDK operation invocation within
 * which the session is created, and the actionContext describing the policy action, if any, that triggered this session
 * creation.
 * promiseFormInput is called right after startSession.
 *
 * After promiseFormInput asyncly returns the SDK will trigger a call to onContinue,onError or endSession, depending on the data sent and the classifiers defined in Management UI server.
 * Calling promiseFormInput will trigger endSession when a fatal error occurs, or when the form is done.
 * In case of a fatal error, the SDK will call UIHandler handlePolicyRejection after calling endSession.
 *
 */
export interface UIFormSession { 

   /**
 * Called to start the form UI session. This is the first function invoke on the session by the SDK.
 * Its purpose is to setup the UI and associate it with the clientContext of the current running action.
 *
 * Implementations should prepare the UI for interaction with the form -- typically (but not necessarily)
 * presenting new UI elements on screen and recording the clientContext.
 *
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked. This is optional since session may be invoked outside the scope of an action.
 */
startSession(clientContext: object | null, actionContext: PolicyAction | null) : void;

   /**
 * End the form session.
 *
 * Implementations should update the UI to reflect the fact that the current authentication session is no longer
 * active; e.g by tearing down UI elements that were setup to collect input for this session.
 */
endSession() : void;

   /**
 * Notify the session that the form processing backend has requested that form interaction will continue to another stage.
 * This method can be multiple times. Each time promiseFormInput().complete() and the response calls for 'continue'.
 * Implementation should update the UI to present the form data received from the server.
 *  @param payload containing the new data received as JSON.
 */
onContinue(payload: object | null) : void;

   /**
 * Notify the session that the form processing backend has requested that an error in form processing will be reported to the user.
 * This method can be multiple times. Each time promiseFormInput.complete() and the response calls for 'continue'.
 * Implementation should update the UI to present the form error received from the server.
 *  @param payload containing the new data received as JSON.
 */
onError(payload: object | null) : void;

   /**
 * Collect input from the session. This function is invoked by the SDK when it wishes to collect input from the
 * @return A promise object. On successful result, returns: A promise object. On successful result, returns: FromInput holding Json object.
 */
promiseFormInput() : Promise<FormInput>;
}
/**
 * Represents a control request from a UI promotion session, asking to continue or dismiss the promotion flow.
 *
 */
export enum PromotionControlRequest {
       /** Cancel the promotion. Does not affect the rest of the authentication process. */
   Skip,
       /** Abort the authentication process altogether, returning an error from the SDK invocation */
   Abort,
       /** Continue promotion by calling the authenticators list via UIPromotionSession#setAuthenticatorsList */
   Continue
}

/**
 * Communicates either an input response or control response from an promotion UI session to the SDK.
 * This is a container that can contain either an AuthenticatorDescription object **or** a PromotionControlType object.
 *
 */
export abstract class PromotionInput { 

   /**
 * Is this a promotion control request?
 *
 * @return true if this object contains a promotion control request (obtained through the controlRequest property), false if it contains an authenticator description (obtained through the description property)
 */
public abstract isControlRequest() : boolean;

/**
 * The control request, if this object represents a control request.
 */
   public getControlRequest() : PromotionControlRequest;

/**
 * The control request, if this object represents a control request.
 */
   public setControlRequest(controlRequest : PromotionControlRequest) : void;

/**
 * The authenticator description, if this object represents an authenticator selection request.
 */
   public getSelectedAuthenticator() : AuthenticatorDescription;

/**
 * The authenticator description, if this object represents an authenticator selection request.
 */
   public setSelectedAuthenticator(selectedAuthenticator : AuthenticatorDescription) : void;

/**
 * The selected escape option, if this object represents an escape option request.
 */
   public getActionEscapeRequest() : ActionEscapeRequest;

/**
 * The selected escape option, if this object represents an escape option request.
 */
   public setActionEscapeRequest(actionEscapeRequest : ActionEscapeRequest) : void;

/**
 * Create a PromotionControlRequest object representing a control request.
 *
 * @param controlRequest the PromotionControlRequest to represent in the created object.
 */
   public static createControlResponse(controlRequest: PromotionControlRequest) : PromotionInput;

/**
 * Create a PromotionInput that encodes a request to escape the action
 *
 * @param actionEscape The escape option to signal
 * @param escapeParams Additional parameters to pass to the journey when escaping.
 */
   public static createEscapeRequest(actionEscape: ActionEscapeOption, escapeParams: object | null) : PromotionInput;

/**
 * Create a PromotionInput object representing an authenticator selection.
 *
 * @param selectedAuthenticator the AuthenticatorDescription to represent in the created object.
 */
   public static createAuthenticatorDescription(selectedAuthenticator: AuthenticatorDescription) : PromotionInput;
}
/**
 * An interface for managing an promotion UI session. When the SDK needs to show promotion, it first creates an
 * form UI session using the application-provided UIHandler. The application then constructs an object implementing
 * this interface, and the SDK invokes callback on this session interface to manage the session lifecycle and
 * interact with the application through the course of the form session.
 *
 * Promotion session ends when the SDK asks to end it.
 *
 * The session lifecycle always begins with a call to startSession, done by the SDK shortly after the session object
 * is created. With startSession the session receives the clientContext for the SDK operation invocation within
 * which the session is created, and the actionContext describing the policy action, if any, that triggered this session
 * creation.
 * promptIntroduction is called right after startSession.
 *
 * After promptIntroduction asyncly returns the SDK will trigger a call to setPromotedAuthenticators or endSession, depending on the PromotionControlRequest provided.Returning Abort or Skip will trigger endSession, Continue will trigger setAuthenticatorsList.
 * After setPromotedAuthenticators asyncly returns the SDK will trigger setPromotedAuthenticators again or endSession.
 * If AuthenticatorDescription was provided, the SDK will either trigger endSession if all promotion conditions were met, or setPromotedAuthenticators to offer registering other authenticators.
 * If PromotionControlRequest of Abort or Skip will be provided, the SDK will trigger endSession.
 *
 */
export interface UIPromotionSession { 

   /**
 * Called to start the promotion UI session. This is the first function invoke on the session by the SDK.
 * Its purpose is to setup the UI and associate it with the clientContext of the current running action.
 *
 * Implementations should prepare the UI for interaction with the promotion -- typically (but not necessarily)
 * presenting new UI elements on screen and recording the clientContext.
 *
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked. This is optional since session may be invoked outside the scope of an action.
 */
startSession(clientContext: object | null, actionContext: PolicyAction | null) : void;

   /**
 * End the promotion session.
 *
 * Implementations should update the UI to reflect the fact that the current authentication session is no longer
 * active; e.g by tearing down UI elements that were setup to collect input for this session.
 */
endSession() : void;

   /**
 * Get user response to promotion screen. This callback is invoked by the SDK to execute a confirmation screen
 * policy action.
 * The callback is expected to present a some UI to the user, collect its input and return it asynchronously to the SDK as a PromotionControlRequest object.
 *
 * @param title Title of promotion screen to display.
 * @param text  Text to display in promotion screen.
 * @param continueText  Label for a promotion button (pressing this button will cause policy execution to continue)
 * @param cancelText Label for a cancellation button (pressing this button will cause policy execution to skip)
 * @return A promise object. On successful result, returns: A promise object. On successful result, returns: A ConfirmationInput object encoding user choice. For the ConfirmationInput#userChoice property, a value of "0" means continue and a value of "1" means cancel.
 */
promptIntroduction(title: string, text: string, continueText: string, cancelText: string) : Promise<PromotionInput>;

   /**
 * Called to provide an updated list of unregistered authenticators. The implementation is expected to choose authenticator to register.
 *
 * @return A promise object. On successful result, returns: On successful result, returns: PromotionInput encoding either an authenticator to register  or a control request to end session.
 */
setPromotedAuthenticators(options: Array<AuthenticatorDescription>) : Promise<PromotionInput>;
}
/**
 * An interface for managing scan qr session. When the SDK needs to show scan QR action, it first creates scan QR
 * UI session using the application-provided UIHandler. The application then constructs an object implementing
 * this interface, and the SDK invokes callback on this session interface to manage the session lifecycle and
 * interact with the application through the course of the form session.
 *
 * Scan QR session ends when the SDK asks to end it.
 *
 * The session lifecycle always begins with a call to startSession, done by the SDK shortly after the session object
 * is created. With startSession the session receives the clientContext for the SDK operation invocation within
 * which the session is created, and the actionContext describing the policy action, if any, that triggered this session
 * creation.
 * promptIntroduction is called right after startSession.
 *
 * After promptIntroduction asyncly returns the SDK will trigger a call to setPromotedAuthenticators or endSession, depending on the PromotionControlRequest provided.Returning Abort or Skip will trigger endSession, Continue will trigger setAuthenticatorsList.
 * After setPromotedAuthenticators asyncly returns the SDK will trigger setPromotedAuthenticators again or endSession.
 * If AuthenticatorDescription was provided, the SDK will either trigger endSession if all promotion conditions were met, or setPromotedAuthenticators to offer registering other authenticators.
 * If PromotionControlRequest of Abort or Skip will be provided, the SDK will trigger endSession.
 *
 */
export interface ScanQrSession { 

   /**
 * Called to start the scan qr session. This is the first function invoke on the session by the SDK.
 * Its purpose is to setup the UI and associate it with the clientContext of the current running action.
 *
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked. This is optional since session may be invoked outside the scope of an action.
 */
startSession(clientContext: object | null, actionContext: PolicyAction | null) : void;

   /**
 * End the scan qr session.
 *
 * Implementations should update the UI to reflect the fact that the current session is no longer
 * active; e.g by tearing down UI elements that were setup to collect input for this session.
 */
endSession() : void;

   /**
 * Get user response to scan QR screen. This callback is invoked by the SDK to execute a scan qr code
 * policy action.
 * The callback is expected to present scan qr code UI to the user, collect its input and return it asynchronously to the SDK as a ScanQrCodeInput object.
 *
 * @param instructions text to display in scan QR code screen
 * @return A promise object. On successful result, returns: InputOrControlResponse encoding either a qr code input or a contorl request with user cancellation
 */
getScanQrResponse(instructions: string, qrCodeFormat: QrCodeFormat) : Promise<InputOrControlResponse<ScanQrCodeInput>>;
}
/**
 * Status of a device -- indicates whether a device is available for use and how recently it was used.
 *
 */
export enum DeviceStatus {
       /** Device was recently used */
   RecentlyUsed,
       /** Device wasn't recently used */
   NoRecentActivity,
       /** Device has been inactive for a long period of time */
   LongInactivity,
       /** Device disabled and cannot be used for login etc */
   Disabled,
       /** Device has just been removed from service, need to login to re-add the device */
   Removed
}

/**
 * Information about a device group
 */
export interface DeviceGroup { 

/**
 * Group identifier, can be used to invoke operations on server management API.
 */
   getId() : string;

/**
 * Human readable group name as defined by the administrator in the Transmit management console.
 */
   getName() : string;
}
/**
 * Human readable location attributes
 */
export interface LocationAttributes { 

   getCity() : string;

   getState() : string;

   getCountry() : string;
}
/**
 * Information about a device known to the Transmit platform.
 *
 */
export interface DeviceInfo { 

/**
 * The Transmit Device Hardware ID for the device.
 */
   getDeviceHwId() : string;

/**
 * Auto-generated or given name of device
 */
   getName() : string;

/**
 * Status of the device
 */
   getStatus() : DeviceStatus;

/**
 * Last device access time
 */
   getLastAccess() : number;

/**
 * Location of last access
 */
   getLastAccessLocation() : GeoLocation;

   getLastAccessLocationAttributes() : LocationAttributes;

/**
 * Time of device registration
 */
   getRegistered() : number;

/**
 * Model of device
 */
   getModel() : string;

/**
 * Type of OS run by the device
 */
   getOsType() : string;

/**
 * Version of OS run by the device
 */
   getOsVersion() : string;

/**
 * Number of times device was used
 */
   getUseCount() : number;

/**
 * Is this object describing the current device?
 */
   getIsCurrent() : boolean;
}
/**
 * An action available on a device in a device management session.
 *
 */
export enum DeviceManagementAction {
       /** Remove a registered device */
   Remove,
       /** Rename a device */
   Rename
}

/**
 * Represents a single device for management within a device management session.
 *
 **/
export interface ManagedDevice { 

/**
 * Information about the managed device represented by this ManagedDevice.
 */
   getInfo() : DeviceInfo;

/**
 * List of actions available within this session on this device.
 */
   getAvailableActions() : Array<DeviceManagementAction>;
}
/**
 * A set of services for conducting a device management session. An implementation of this object is passed to the
 * application to allow it to carry out device management operations.
 *
 * After successful completion of each of these services, the list of devices passed to application at the beginning of the
 * session may change; this will be done via a call to UIDeviceManagementSession#setSessionDevicesList.
 *
 */
export interface DeviceManagementSessionServices { 

/**
 * UIContext contains ui utils.
 */
   getUiContext() : UIContext;

   /**
 * Remove a managed device.
 *
 * Calling this on the current device will cause an error to be raised. To delete the current device use
 * #removeCurrentDeviceAndFinishSession.
 *
 * @param device Device to operate on.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the context of this invocation.
 * @return A promise object. On successful result, returns: true to indicate successful completion.
 */
removeDevice(device: ManagedDevice, clientContext: object | null) : Promise<boolean>;

   /**
 * Change the name of a registered managed device.
 *
 * @param device Device to operate on.
 * @param newName New name for device.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the context of this invocation.
 * @return A promise object. On successful result, returns: true to indicate successful completion.
 */
renameDevice(device: ManagedDevice, newName: string, clientContext: object | null) : Promise<boolean>;

   /**
 * Request to refresh devices list from the server. This will asyncly return after device list is updated
 * from the server and delivered to the session via a call to UIDeviceManagementSession#setSessionDevicesList.
 * @return A promise object. On successful result, returns: true to indicate successful operation.
 */
requestRefreshDevices() : Promise<boolean>;

   /**
 * Remove the current device from the server, and then finish the current device management session,
 * clear the current logged in session and clear the current user data from the device -- completing
 * an orderly and clean device unregistration.
 *
 
 * This call will asynchronously return once the server request to remove the current device completes.
 * After this asynchronously returns, the same sequence of calls that occurs on a call to #finishSession
 * executes, but prior to the #startDeviceManagementSession asyncorhonus call returning the session will be
 * logged off and the current user's persistent data will be cleared.
 *
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the context of this invocation.
 * @return A promise object. On successful result, returns: true to indicate successful completion.
 */
removeCurrentDeviceAndFinishSession(clientContext: object | null) : Promise<boolean>;

   /**
 * Request to end the session. This will cause endSession to be called on the UIDeviceManagementSession.
 */
finishSession() : void;
}
/**
 * An interface for managing a device management UI session. When the SDK is required to allow the user to manage
 * his devices, it first creates a device management UI session using the application-provided UIHandler. The
 * application then constructs an object implementing this interface, and the SDK invokes callback on this session
 * interface to manage the session lifecycle and interact with the application through the course of the device management
 * session.
 *
 * The session lifecycle always begins with a call to startSession, done by the SDK shortly after the session object
 * is created.  With startSession the session receives the clientContext for the SDK operation invocation within
 * which the session is created, and the actionContext describing the policy action, if any, that triggered this session
 * creation. Also, the SDK passes a DeviceManagemenetSessionServices object to this session, using which the
 * application can invoke operations on devices or the session itself.
 *
 * A device management session operates on a list of devices registered for the user. This list may be updated during session
 * lifetime. When this happens, UIDeviceManagementSession#setSessionDevicesList is invoked by the SDK. This happens
 * right before the session is started and between invocation of device services made by the application (see below).
 *
 * Once it has a list of devices and the services provider, the client may invoke operations on devices. Each device
 * in the list of devices is accompanied with a specification of which management operations are available
 * for it. The application may invoke services in the deviceManagementSession object provided on session start
 * to actually invoke these operations. Note that operations may only be invoked on device objects provided to this session through
 * #setSessionDevicesList.
 *
 * When the application decides the device management session is complete (e.g the user asked to close an device management UI), it
 * invokes the DeviceManagementSessionServices#finishSession callback. When either the SDK or the application decide
 * to finish the session, the SDK will invoke endSession().
 *
 * The application may also terminate the device management sesion by removing the current device. This is done by
 * invoking removeCurrentDeviceAndFinishSession, and will cause removal of the device in the server followed by termination
 * of the device management session, logging out of the current user session and finally clearing the user data from the SDK.
 *
 */
export interface UIDeviceManagementSession { 

   /**
 * Called to provide an updated list of managed devices to the session. The implementation is expected to refresh
 * the UI as needed to reflect the new list.
 *
 * @param devices Updated list of devices for the current session.
 */
setSessionDevicesList(devices: Array<ManagedDevice>) : void;

   /**
 * Called to start the device management session. This is invoked by the SDK shortly after the session is created and
 * after the initial call to #setSessionDevicesList.
 *
 * The implementation is expected to setup the UI and associate it with the clientContext and actionContext
 * of the current running authentication action, as well keep a reference to the deviceManagementSessionServices
 * object to invoke it to perform operations on devices during the session.
 *
 * @param deviceManagementSessionServices An interface provided to the application for performing actions on devices and the session itself.
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked. This is optional since session may be invoked outside the scope of an action.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 */
startSession(deviceManagementSessionServices: DeviceManagementSessionServices, actionContext: PolicyAction | null, clientContext: object | null) : void;

   /**
 * End the device management session.
 *
 * Implementations should update the UI to reflect the fact that the current device management session is no longer
 * active; e.g by tearing down UI elements that were setup to collect input for this session.
 */
endSession() : void;
}
/**
 * An action available on an authenticator in an authentication configuration session.
 *
 */
export enum AuthenticatorConfigurationAction {
       /** Register an (unregistered) authenticator */
   Register,
       /** Unregister a registered authenticator */
   Unregister,
       /** Re-register an already registered authenticator */
   Reregister
}

/**
 * Represents a single authenticator for configuration within an authentication configuration session.
 *
 **/
export interface ConfigurableAuthenticator { 

/**
 * Information about the authenticator represented by this ConfigurableAuthenticator.
 */
   getDescription() : AuthenticatorDescription;

/**
 * List of actions available within this session on this authenticator.
 */
   getAvailableActions() : Array<AuthenticatorConfigurationAction>;
}
/**
 * A set of services for conducting an authentication configuration session. An implementation of this object is
 * passed to the application to allow it to carry out operations relevant to authentication configuration.
 *
 * After successful completion of each of these services, the list of authenticators passed to the application
 * at the beginning of the session may change; the application will be notified of such changes through a all to
 * UIAuthenticationConfigurationSession#setAuthenticatorsList.
 *
 * Note that some operations may trigger additional UIHandler callbacks, e.g to initiate policy execution for
 * authenticating a registration request. Some of these may create other UI sessions (e.g for authenticators).
 *
 */
export interface AuthenticationConfigurationSessionServices { 

/**
 * UIContext contains ui utils.
 */
   getUiContext() : UIContext;

   /**
 * Register an authenticator. This call will initiate execution of a control flow to authenticate the registration.
 *
 * @param authenticator Authenticator to register.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the context of this invocation.
 * @return A promise object. On successful result, returns: AuthenticationResult for the policy executed as part of successful registration.
 */
registerAuthenticator(authenticator: ConfigurableAuthenticator, clientContext: object | null) : Promise<AuthenticationResult>;

   /**
 * Re-register an already registered authenticator. This call will initiate execution of a control flow to
 * authenticate the registration.
 *
 * @param authenticator Authenticator to re-register.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the context of this invocation.
 * @return A promise object. On successful result, returns: AuthenticationResult for the policy executed as part of successful re-registration.
 */
reregisterAuthenticator(authenticator: ConfigurableAuthenticator, clientContext: object | null) : Promise<AuthenticationResult>;

   /**
 * Unregister an authenticator. This call will initiate execution of a control flow to deregister the authenticator.
 *
 * @param authenticator Authenticator to unregister.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the context of this invocation.
 * @return A promise object. On successful result, returns: true to indicate successful completion.
 */
unregisterAuthenticator(authenticator: ConfigurableAuthenticator, clientContext: object | null) : Promise<boolean>;

   /**
 * Request to refresh list of authenticators for this user from the server. This will asyncly return after
 * the list is updated from the server and delivered to the session via a call to
 * UIAuthenticationConfigurationSession#setAuthenticatorsList.
 * @return A promise object. On successful result, returns: true to indicate successful operation.
 */
requestRefreshAuthenticators() : Promise<boolean>;

   /**
 * Request to set an authenticator as the default authenticator.
 * @return A promise object. On successful result, returns: true to indicate succesful operation
 */
setDefaultAuthenticator(authenticator: ConfigurableAuthenticator) : Promise<boolean>;

   /**
 * Request to end the session. This will cause endSession to be called on the UIAuthenticationConfigurationSession
 * object representing the session bound to this services object.
 */
finishSession() : void;
}
/**
 * An interface for managing an authentication configuration UI session. When the SDK is required to start an
 * authentication configuration session, it first creates an authentication configuration UI session using the
 * application-provided UIHandler. The application then constructs an object implementing this interface, and
 * the SDK invokes callback on this session interface to manage the session lifecycle and interact with the
 * application through the course of the device authentication configuration session.
 *
 * Typically the authentication configuration session ends when the application asks to end it. Regardless of whether the
 * application or the SDK terminate the approval session, its endSession method is invoked.
 *
 * The session lifecycle always begins with a call to startSession, done by the SDK shortly after the session object
 * is created.  With startSession the session receives the clientContext for the SDK operation invocation within
 * which the session is created, and the actionContext describing the policy action, if any, that triggered this session
 * creation. Also, the SDK passes an AuthenticationConfigurationSessionServices object to this session, using which the
 * application can invoke operations on authenticators or the session itself.
 *
 * An authentication configuration session operates on a list of authenticators registered for the user. This list may
 * be updated during session lifetime. When this happens, UIAuthenticationConfigurationSession#setAuthenticatorsList is
 * invoked by the SDK. This happens right before the session is started and between invocation of
 * AuthenticationConfigurationSessionServices services made by the application (see below).
 *
 * Once it has a list of authenticators and the services provider, the application may invoke operations on devices.
 * Each device in the list of devices is accompanied with a specification of which operations are available
 * for it. The application may invoke services in the authenticationConfigurationSessionServices object provided on
 * session start to actually invoke these operations. Note that operations may only be invoked on authenticator
 * objects provided to this session through #setAuthenticatorsList.
 *
 * When the application decides the session is complete (e.g the user asked to close an authentication configuration
 * screen), it invokes the AuthenticationConfigurationSessionServices#finishSession callback. When either the SDK or
 * the application decide to finish the session, the SDK will invoke endSession().
 *
 */
export interface UIAuthenticationConfigurationSession { 

   /**
 * Called to provide an updated list of authenticators to configure to the session. The implementation is expected to refresh
 * the UI as needed to reflect the new list.
 *
 * @param authenticators Updated list of authenticators for configuration in the current session.
 */
setAuthenticatorsList(authenticators: Array<ConfigurableAuthenticator>) : void;

   /**
 * Called to start the authentication configuration session. This is invoked by the SDK shortly after the session is created and
 * after the initial call to #setAuthenticatorsList.
 *
 * The implementation is expected to setup the UI and associate it with the clientContext and actionContext
 * of the current running authentication action, as well keep a reference to the authenticationConfigurationSessionServices
 * object to invoke it to perform operations on authenticators and the session itself during the session.
 *
 * @param authenticationConfigurationSessionServices An interface provided to the application for performing actions on authenticators and the session itself.
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked. This is optional since session may be invoked outside the scope of an action.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 */
startSession(authenticationConfigurationSessionServices: AuthenticationConfigurationSessionServices, actionContext: PolicyAction | null, clientContext: object | null) : void;

   /**
 * End the authentication configuration session.
 *
 * Implementations should update the UI to reflect the fact that the current authentication configuration session
 * is no longer active; e.g by tearing down UI elements that were setup to collect input for this session.
 */
endSession() : void;
}
/**
 * The status of a mobile approval record.
 *
 */
export enum MobileApprovalStatus {
       /** Pending user's confirmation */
   Pending,
       /** Approved */
   Approved,
       /** Denied */
   Denied,
       /** Request expired */
   Expired
}

/**
 * Contents of a mobile approval request
 *
 */
export interface MobileApproval { 

/**
 * Approval Identifier.
 */
   getApprovalId() : string;

/**
 * Remote source that created the approval.
 * Transmit Management console refers to source as "Title 2".
 * Referred as "Title 2" by Transmit Server.
 */
   getSource() : string;

/**
 * Approval title for the user.
 * Transmit Management console refers to source as "Title 1".
 */
   getTitle() : string;

/**
 * Approval text for the user.
 */
   getDetails() : string;

/**
 * Creation time.
 */
   getCreationTime() : number;

/**
 * Completion time (if completed)
 */
   getFinishTime() : number;

/**
 * Expiration time
 */
   getExpiresAt() : number;

/**
 * Mobile approval status.
 */
   getStatus() : MobileApprovalStatus;

/**
 * The application Id.
 */
   getOriginAppId() : string;

/**
 * The approval location
 */
   getLocation() : GeoLocation;

/**
 * The origin device who request approve.
 */
   getOriginDevice() : TargetDeviceDetails | null;

/**
 * Additional custom params.
 */
   getCustomParams() : object;

   /** Returns true if the approal has expired, false otherwise. */
isExpired() : boolean;
}
/**
 * An action available on a mobile approval in a mobile approval session.
 *
 */
export enum MobileApprovalAction {
       /** Confirm an approval */
   Approve,
       /** Deny an approval */
   Deny
}

/**
 * Represents a single mobile approval for operation within a mobile approval session.
 *
 **/
export interface ManagedMobileApproval { 

/**
 * Information about the approval represented by this ManagedMobileApproval.
 */
   getApproval() : MobileApproval;

/**
 * List of actions available within this session on this approval.
 */
   getAvailableActions() : Array<MobileApprovalAction>;
}
/**
 * A set of operations for execution on approvals in a mobile approval session. An implementation of this object is passed to the
 * application to allow it to carry out approval management operations, in the call to the UIApprovalsSession#startSession
 * callback.
 *
 * After successful completion of each of these services, the list of approvals associated with the session may change;
 * this is communicated to the application through an invocation of UIApprovalSession#setSessionApprovalsList.
 *
 */
export interface ApprovalManagementSessionServices { 

/**
 * UIContext contains ui utils.
 */
   getUiContext() : UIContext;

   /**
 * Confirm an approval.
 * This may trigger an authentication policy execution. If that's the case, all callbacks invoked as part of this
 * policy execution will have the clientContext parameter passed to this call passed to them.
 *
 * @param approval Approval to operate on.
 * @param clientContext A clientContext to use for all invocations run as part of this approval operation (e.g when there's
 * @return A promise object. On successful result, returns: an AuthenticationResult object to indicate successful completion.
 */
approve(approval: ManagedMobileApproval, clientContext: object | null) : Promise<AuthenticationResult>;

   /**
 * Deny an approval.
 *
 * @return A promise object. On successful result, returns: true to indicate succesful operation.
 */
deny(approval: ManagedMobileApproval) : Promise<boolean>;

   /**
 * Request to refresh approvals list from the server. This will asyncly return after approvals list is updated
 * from the server and delivered to the session via a call to UIApprovalsSession#setSessionApprovalsList.
 * @return A promise object. On successful result, returns: true to indicate successful operation.
 */
requestRefreshApprovals() : Promise<boolean>;

   /**
 * Request to end the session. This will cause endSession to be called on the UIApprovalsSession.
 */
finishSession() : void;
}
/**
 * An interface for managing an approvals UI session. When the SDK needs to show approvals, it first creates an
 * approval UI session using the application-provided UIHandler. The application then constructs an object implementing
 * this interface, and the SDK invokes callback on this session interface to manage the session lifecycle and
 * interact with the application through the course of the approval session.
 *
 * Typically the approval session ends when the application asks to end it. Regardless of whether the application or
 * the SDK terminate the approval session, its endSession method is invoked.
 *
 * The session lifecycle always begins with a call to startSession, done by the SDK shortly after the session object
 * is created.  With startSession the session receives the clientContext for the SDK operation invocation within
 * which the session is created, and the actionContext describing the policy action, if any, that triggered this session
 * creation. Also, the SDK passes an ApprovalManagemenetSessionServices object to this session, using which the
 * application can invoke operations on approvals (such as deny, approve) or the session itself.
 *
 * An approvals session has an associated list of approvals managed by it. This list may be updated during session
 * lifetime. When this happens, UIApprovalsSession#setSessionApprovalsList is invoked by the SDK. This happens
 * right before the session is started and between invocation of approval services made by the application (see below).
 *
 * Once it has a list of approvals and the services providers, the client may invoke operations on approvals. Approvals
 * in the list include an indication of which operations are permitted on them. Note that some operations may trigger
 * additional UIHandler callbacks, e.g to initiate policy execution for an approval. Some of these may create other UI sessions
 * (e.g for authenticators). Between operation invocations, the SDK may update the approvals list for the session. Note
 * that the methods in ApprovalManagemenetSessionServices must only be invoked on approval objects from the current approval
 * list in the session.
 *
 * When the application decides the approvals session is complete (e.g the user asked to close an approvals UI), it
 * invokes the ApprovalManagementSessionServices#finishSession callback. When either the SDK or the application decide
 * to finish the session, the SDK will invoke endSession().
 *
 */
export interface UIApprovalsSession { 

   /**
 * Called to provide an updated list of managed approvals to the session. The implementation is expected to refresh
 * the UI as needed to reflect the new list.
 *
 * @param approvals Updated list of approvals for the current session.
 */
setSessionApprovalsList(approvals: Array<ManagedMobileApproval>) : void;

   /**
 * Called to start the approvals session. This is invoked by the SDK shortly after the session is created and
 * after the initial call to #setSessionApprovalsList.
 *
 * The implementation is expected to setup the UI and associate it with the clientContext and actionContext
 * of the current running authentication action, as well keep a reference to the approvalManagementSessionServices
 * object to invoke it to perform operations on approvals during the session.
 *
 * @param approvalManagementSessionServices An interface provided to the application for performing actions on approvals and the session itself.
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked. This is optional since session may be invoked outside the scope of an action.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 */
startSession(approvalManagementSessionServices: ApprovalManagementSessionServices, actionContext: PolicyAction | null, clientContext: object | null) : void;

   /**
 * End the approvals session.
 *
 * Implementations should update the UI to reflect the fact that the current approvals session is no longer
 * active; e.g by tearing down UI elements that were setup to collect input for this session.
 */
endSession() : void;
}
/**
 * A response to ticket wait action. The object represents the response sent from the client
 * to the SDK when asked to display ticket ID and wait for an extranal scan or input. The
 * action in this case is a polling request, requiring the SDK to check if the
 * ticket is already consumed.
 *
 * There are two types of polling requests: long polling and short polling. A short polling request issues a request
 * to the server that returns immediately, either indicating that the ticket was consumed, or indicating
 * the ticket is still pending (in which case the session is not done and promiseInput will be invoked again).
 * Clients should request the SDK for short polling requests periodically (eg. once every 3 seconds). To do this,
 * a client would typically create a timer in a call to UITicketWaitSession#promiseInput, such that promiseInput
 * will return the polling request asynchronously after that period. With a polling period of P it may take up to
 * period P to detect that a ticket was consumed (or on average P/2).
 *
 * A long polling request indicates to the server that it should return a response as soon as a ticket is consumed
 * -- or after a timeout occurs (the timeout is configurable in the long polling request). Here a client would typically issue the
 * long polling request immediately on invocation of UITicketWaitSession#promiseInput, specifiying a timeout
 * period P. If ater period P the ticket is still pending, promiseInput will be invoked again (and will probably return the same
 * long polling request.)
 *
 */
export abstract class TicketWaitInput extends InputResponseType { 

/**
 * Create a TicketWaitInput object representing a short polling request.
 */
   public static createPollRequest() : TicketWaitInput;

/**
 * Create a TicketWaitInput object representing a long polling request, with
 * given timeout in seconds.
 */
   public static createLongPollRequest(timeoutInSeconds: number) : TicketWaitInput;
}
export class TicketWaitInputPollRequest extends TicketWaitInput { 

/**
 * If nonzero -- timeout in seconds for long polling request to issue.
 * If zero -- this is a short poll request.
 */
   public getPollingTimeout() : number;

/**
 * If nonzero -- timeout in seconds for long polling request to issue.
 * If zero -- this is a short poll request.
 */
   public setPollingTimeout(pollingTimeout : number) : void;
}
export enum TicketIdFormat {
       /** QR code */
   Qr,
       /** Alphanumeric code */
   Alphanumeric
}

/**
 * Represents ticket ID information, as provider by the server to the ticket-wait
 * action. This will typically be used to be rendered by the UI layer.
 *
 */
export interface TicketId { 

/**
 * The format of the proivided ticket ID. The format instructs how to use the value attribute.
 */
   getFormat() : TicketIdFormat;

/**
 * The value of the ticket ID, matching the provided format. For Qr format, this will
 * be a Base64 encoded JPEG. For Alphanumeric format this will be a simple string.
 */
   getValue() : string;

/**
 * An alternative representaiton of the value. For Qr format, this will be the text
 * encoded by the QR code.
 */
   getValueAltRepresentation() : string | null;
}
/**
 * Represents the information from the server regarding the ticket wait action. This includes a
 * message to the user (title and text), and an optional ticket ID in some format. The UI layer should
 * display this when received.
 *
 */
export interface TicketWaitingInformation { 

   getTitle() : string;

   getText() : string;

   getTicketId() : TicketId | null;
}
/**
 * An interface for managing a ticket wait session. When the SDK needs to wait for a ticket, it creates an instance
 * of this object and manages the action through services of this interface.
 *
 * The session lifecycle always begins with a call to startSession, done by the SDK shortly after the session object
 * is created through UIHandler#createTicketWaitSession. With startSession the session receives the clientContext for
 * the SDK operation invocation within which the session is created.
 *
 * Right before the session begins its lifecycle, the #setWaitingTicket call is invoked to provide informaton about
 * the ticket that's being waited upon (e.g the ticket ID and instructions to present to the user).
 *
 * After the call to startSession, the SDK will call promiseInput() -- providing the UI handler a chance to either
 * cancel the ticket wait operation by returning a proper control response, or ask to poll for ticket consumption.
 * As a result from a poll request, the sessino may end (if the ticket was consumed, or expired, etc.), or #promiseInput
 * may be invoked again -- providing the client with further opportunity to cancel or ask for polling. Typical client
 * implementations will, in response to promiseInput, either handle a cancel request from the UI or wait for a polling
 * period and then ask the SDK to poll for ticket status again.
 *
 * When the SDK can complete the ticket wait action (succesfuly or failing), it will invoke
 * endSession to signal that the authentication session has ended.
 *
 */
export interface UITicketWaitSession { 

   /**
 * Sets the ticket information for the session
 */
setWaitingTicket(ticketWaitInfo: TicketWaitingInformation) : void;

   /**
 * Called to start the ticket wait session. This is invoked by the SDK shortly after the session is created, and after
 * setWaitingTicket was called.
 *
 * The implementation is expected to setup the UI and associate it with the clientContext and actionContext.
 * It should display the information provided by setWaitingTicket
 *
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked. This is optional since session may be invoked outside the scope of an action.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 */
startSession(actionContext: PolicyAction | null, clientContext: object | null) : void;

   /**
 * The implementation is expected to set a poll timeout, and once ended return a TicketWaitInput.createPollRequest().
 * @return A promise object. On successful result, returns: InputOrControlResponse encoding either a ticket wait input or a control request. Only ControlRequestType#CancelAuthenticator is supprted as a control request.
 */
promiseInput() : Promise<InputOrControlResponse<TicketWaitInput>>;

   /**
 * End the wait for ticket session.
 *
 * Implementations should update the UI to reflect the fact that the current ticket wait session is no longer
 * active; e.g by stopping the polling mechanism, removing UI elements, etc.
 */
endSession() : void;
}
/**
 * Represents a header sent with a request or a response in the transport protocol.
 *
 */
export class TransportHeader { 

/**
 * Name of header.
 */
   public getName() : string;

/**
 * Name of header.
 */
   public setName(name : string) : void;

/**
 * Value of header.
 */
   public getValue() : string;

/**
 * Value of header.
 */
   public setValue(value : string) : void;
}
/**
 * Represents a request to be sent via the SDK transport.
 *
 */
export class TransportRequest { 

/**
 * URL of request.
 */
   public getUrl() : string;

/**
 * URL of request.
 */
   public setUrl(url : string) : void;

/**
 * Request method
 */
   public getMethod() : string;

/**
 * Request method
 */
   public setMethod(method : string) : void;

/**
 * Request headers
 */
   public getHeaders() : Array<TransportHeader>;

/**
 * Request headers
 */
   public setHeaders(headers : Array<TransportHeader>) : void;

/**
 * Request body.
 */
   public getBodyJson() : string;

/**
 * Request body.
 */
   public setBodyJson(bodyJson : string) : void;
}
/**
 * Represents a response received via SDK transport.
 *
 */
export class TransportResponse { 

/**
 * Response status code
 */
   public getStatus() : number;

/**
 * Response status code
 */
   public setStatus(status : number) : void;

/**
 * Response status reason
 */
   public getMethod() : string;

/**
 * Response status reason
 */
   public setMethod(method : string) : void;

/**
 * Response headers
 */
   public getHeaders() : Array<TransportHeader>;

/**
 * Response headers
 */
   public setHeaders(headers : Array<TransportHeader>) : void;

/**
 * Response body.
 */
   public getBodyJson() : string;

/**
 * Response body.
 */
   public setBodyJson(bodyJson : string) : void;
}
/**
 * An interface representing a transport for use by the SDK when communicating with the server.
 *
 */
export interface TransportProvider { 

   /**
 * Used to ask the transport provider to send a request to the server. Implementations of this interface should
 * send the request and return the response asynchronously.
 *
 * @return A promise object. On successful result, returns: A TransportResponse object representing the response from the server.
 */
sendRequest(request: TransportRequest) : Promise<TransportResponse>;
}
export class JourneyInvocationOptions { 

   public getFlowId() : string;

   public setFlowId(flowId : string) : void;
}
export class AuthenticateInvocationOptions extends JourneyInvocationOptions { 
}
export class BindInvocationOptions extends JourneyInvocationOptions { 
}
export class PolicyInvocationOptions extends JourneyInvocationOptions { 
}
export class AnonymousPolicyInvocationOptions extends JourneyInvocationOptions { 
}
export class ApprovalPolicyInvocationOptions extends JourneyInvocationOptions { 
}
/**
 * Client-provided callbacks for the SDK. This is the primary interface between the SDK and the client. An
 * implementation of this interface must be connected to the SDK by calling TransmitSDKXm#setUiHandler. Whenever
 * the SDK requires user or client input during operations such as policy invocation, it would invoke callbacks
 * implemented in this class.  The UI handler set at the time of policy invocation will be used throughout that
 * entire invocation, even if during invocation another call to TransmitSDKXm#setUiHandler replaces the UI handler.
 *
 * Most of the callbacks in this interface receive a clientContext. This is a map of objects provided by the client
 * when invoking an SDK operation, such as TransmitSDKXm#authenticate. The map of objects provided to the invocation
 * call will be passed back by the SDK in callback invocations that are initiated as part of this call. This makes the
 * clientContext parameter useful for relating callback invocations to the original invocations that initiated them.
 *
 * Callbacks used to receive input from the application, such as selectAuthenticator, follow an asynchronous
 * calling model where the input (such as a user selection or user input) is returned asynchronously after callback
 * invocation. This allows implementations of this interface to collect information from the user and return it
 * as the user becomes available, without blocking the input request call.
 *
 * The SDK communicates the commencement and termination of long-running background operations by invoking
 * startActivityIndicator and endActivityIndicator.
 *
 * Authentication actions are handled by invocations to selectAuthenticator, selectAuthenticatorFallbackAction,
 * controlOptionForCancellationRequestInSession, and the different authenticator session calls (of the form
 * createXXXXXAuthSession). Note that for authenticator sessions, the clientContext parameter is not passed to the
 * creation call but rather when UIAuthenticatorSession#startSession is invoked.
 *
 * Approvals, device management and authentication configuration menu are all handled by calls to
 * create[session-type]Session. Each of these calls creates a session for one of these activities, and through that
 * session object the SDK notifies the UI of changes to data that it presents, and receives requests to perform
 * actions available in the session.
 *
 * Simpler user input, such as responses to confirmation and information messages is obtained by the SDK invoking
 * calls such as getConfirmationInput, getInformationResponse.
 *
 * When an authentication policy includes a JSON processing action, processJsonData is invoked for handling the
 * provided JSON data.
 *
 * Rejection is signalled by a call to handlePolicyRejection.
 *
 *
 */
export interface UIHandler { 

   /**
 * Show activity indicator. This callback is invoked by the SDK to indicate that a long-running operation is starting.
 * When the long-running operation ends, endActivityIndicator will be invoked.
 *
 * For a given SDK operation invocation, two calls to startActivityIndicator may not be made without an
 * intermediate call to endActivityIndicator for the same operation. However, there are no constraints on calls
 * to these functions for different operation invocations.
 *
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked. This is optional since background activity can be initiated before the first action or after the last action as well.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 */
startActivityIndicator(actionContext: PolicyAction | null, clientContext: object | null) : void;

   /**
 * Hide activity indicator. This callback is invoked by the SDK to indicate that a long-running operation has ended.
 * When the long-running operation ends, endActivityIndicator will be invoked.
 *
 * For a given SDK operation invocation, two calls to startActivityIndicator may not be made without an
 * intermediate call to endActivityIndicator for the same operation. However, there are no constraints on calls
 * to these functions for different operation invocations.
 *
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked. This is optional since background activity can be initiated before the first action or after the last action as well.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 */
endActivityIndicator(actionContext: PolicyAction | null, clientContext: object | null) : void;

   /**
 * Invoked to notify the UI handler that a control flow is being cancelled programatically due to a call to
 * TransmitSDKXm#cancelCurrentRunningControlFlow. This is a good chance for the UI handler
 * to tear down all UI currently setup for the control flow.
 *
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 */
controlFlowCancelled(clientContext: object | null) : void;

   /**
 * Invoked to notify the UI handler that a control flow is being started.
 *
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 */
controlFlowStarting(clientContext: object | null) : void;

   /**
 * Invoked to notify the UI handler that a control flow has ended.
 *
 * @param error If the flow is ending with an error, this is the error causing it to end. If the flow has completed succesfully, this is null.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 */
controlFlowEnded(error: AuthenticationError | null, clientContext: object | null) : void;

   /**
 * Invoked to notify the UI handler that a control flow action is being started.
 *
 * @param actionContext Information on the policy action being started.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 */
controlFlowActionStarting(actionContext: PolicyAction | null, clientContext: object | null) : void;

   /**
 * Invoked to notify the UI handler that a control flow action has ended.
 *
 * @param error If the action is ending with an error, this is the error causing it to end. If the action has completed succesfully, this is null.
 * @param actionContext Information on the policy action that has ended.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 */
controlFlowActionEnded(error: AuthenticationError | null, actionContext: PolicyAction | null, clientContext: object | null) : void;

   /**
 * Unregister an authenticator session. This callback is invoked by the SDK as part of
 * an deregister action.
 *
 * The callback receives information about the to-be unregistered authenticator: description and is placeholder authenticator.
 * The callback is expected to return a result asynchronously as a UnregistrationInput object.
 *
 * @param authenticatorDescription The authenticator that will be unregistered.
 * @param isPlaceholder Is this authenticator of placeholder type or not.
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 * @return A promise object. On successful result, returns: A UnregistrationInput object encoding user choice. For the UnregistrationInput#userChoice property, a value of "0" means unregister and a value of "1" means leave authenticator registered and fail policy.
 */
handleAuthenticatorUnregistration(authenticatorDescription: AuthenticatorDescription, isPlaceholder: boolean, actionContext: PolicyAction | null, clientContext: object | null) : Promise<UnregistrationInput>;

   /**
 * Invoked by the SDK prior to invoking #selectAuthenticator, to allow the UI handler to specify whether
 * authenticators that are disabled (e.g locked or unregistered) should be included in the list of authenticators
 * provided to #selectAuthenticator.
 *
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 *
 * @return true if disabled authenticators should be included in the list provided to selectAuthenticator; false otherwise.
 */
shouldIncludeDisabledAuthenticatorsInMenu(actionContext: PolicyAction | null, clientContext: object | null) : boolean;

   /**
 * Select an authenticator from a list of options. This callback is invoked by the SDK as part of processing an
 * action that requires selecting an authenticator among a list of authenticators. One example to such a scenario is
 * when executing a Primary or Secondary authentication action with more than one authenticator.
 *
 * An implementation may allow the user to select one of the authenticators or otherwise select by applying some
 * application-defined logic.
 *
 * The asynchronously-returned AuthenticatorSelectionResult can either encode cancellation
 * (AuthenticatorSelectionResult#createAbortRequest) or an authenticator selection
 * (AuthenticatorSelectionResult#createSelectionRequest or
 * AuthenticatorSelectionResult#createParameterizedSelectionRequest). In the case of a selection, the selected
 * AuthenticatorDescription must be the authenticator description of one of the options passed in the options
 * parameter. Moreover, it must be an object that is enabled -- by AuthenticatorDescription#enabled. Failure to
 * meet these requirements will trigger a failure in the originating SDK operation invocation with error
 * AuthenticationErrorCode#AppImplementation.
 *
 * The implementation may also provide, in additional to the selected authenticator, futher parameters to the
 * authentication process. This is done by returning an object constructed by calls to
 * AuthenticatorSelectionResult#createParameterizedSelectionRequest. The authentication parameters valid for this
 * call depend on the authenticator type. For example for a target-based authenticator such as OTP the parameters
 * may include a selection of an OTP target. Where an authenticator type supports parameters, the SDK may include
 * suggested parameters in the AuthenticationOption object. For example for target-based authenticators, the
 * AuthenticationOption#suggestedParameters property will include a list of possible targets and by returning one of
 * them in the AuthenticatorSelectionResult object the implementation may select the corresponding target (the
 * implementation may choose not to include any of the target parameters which will cause the SDK to ask for target
 * selection).
 *
 * @param options List of authenticators to select from.
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 * @return A promise object. On successful result, returns: An AuthenticatorSelectionResult object signalling either a selected authenticator or request to abort the flow
 */
selectAuthenticator(options: Array<AuthenticationOption>, actionContext: PolicyAction | null, clientContext: object | null) : Promise<AuthenticatorSelectionResult>;

   /**
 * Select action to perform when authenticator fallback is needed. This callback is invoked by the SDK as
 * part of an authentication action (e.g Primary or Secondary authentication), when an authentication fallback
 * threshold is defined and the user has reached that failure threshold when attempting authentication.
 *
 * The SDK then invokes the fallback action callback to allow the application to decide how to respond to the suggestion
 * to fallback. The callback is provided with information on the valid responses for fallback based on current available
 * authenticators and the policy definition for acceptable fallbacks. If the policy defines a specific authenticator
 * to fallback to, this is also provided to the callback.
 *
 * An implementation may allow the user to select a fallback action or run application-specific logic to make that
 * decision.
 *
 * The asynchronously-returned AuthenticatorFallbackAction value must be one of the values listed in the validOptions
 * parameter. Failure to meet this requirement will trigger a failure in the originating SDK operation invocation.
 *
 * See AuthenticatorFallbackAction for the possible responses from this callback and their meaning.
 *
 * @param validOptions List of fallback response actions to choose form.
 * @param fallbackAuth For the AuthenticatorFallbackAction#Fallback value, the authenticator to which fallback will be done
 * @param session The UIAuthenticatorSession during which a fallback request has occurred.
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 * @return A promise object. On successful result, returns: AuthenticatorFallbackAction describing the action to take.
 */
selectAuthenticatorFallbackAction(validOptions: Array<AuthenticatorFallbackAction>, fallbackAuth: AuthenticatorDescription | null, session: UIAuthenticatorSession<InputResponseType>, actionContext: PolicyAction | null, clientContext: object | null) : Promise<AuthenticatorFallbackAction>;

   /**
 * Select control request action to perform in response to authentication cancellation request. This callback is
 * invoked by the SDK as part of an authentication action (e.g Primary or Secondary authentication), when authentication
 * cancellation is requested by the user (or the application). Authentication cancellation request is signalled to
 * the SDK by returning a control response with type ControlRequestType#CancelAuthenticator from
 * UIAuthenticatorSession#promiseInput. When the client returns this value, the SDK will normally respond by invoking
 * the controlOptionForCancellationRequestInSession callback to "trade" this control request with a control
 * request which is NOT ControlRequestType#CancelAuthenticator. The control request returned by this callback is
 * then used in lieu of the original control request returned from UIAuthenticatorSession#promiseInput.
 *
 * This callback allows (and in fact, encourages) applications to implement a uniform response to use cancellation
 * request regardless of the exact type of authentication session such a request is defined in.
 *
 * The SDK may decide to enable or disable some possible control request types when invoking this callback. The
 * enabled, or permissible, control request types are available in the validOptions parameter. The returned
 * control request must be one of these request types. Failure to meet this requirement will trigger a failure in
 * the originating SDK operation invocation.
 *
 * See ControlRequest for the possible responses from this callback and their meaning.
 *
 * @param validOptions List of control request types to choose form.
 * @param session The UIAuthenticatorSession during which a cancellation request has occurred.
 * @return A promise object. On successful result, returns: ControlRequest describing the control request to use in lieu of the ControlRequestType#CancelAuthenticator
 */
controlOptionForCancellationRequestInSession(validOptions: Array<ControlRequestType>, session: UIAuthenticatorSession<InputResponseType>) : Promise<ControlRequest>;

   /**
 * Create an authenticator session for the Password authenticator. This callback is invoked by the SDK as part of
 * an authentication action (e.g Primary or Secondary authentication), when this authenticator needs to be invoked.
 *
 * The callback receives information about the current authentication session such as title, username and any
 * other constraints on the authentication session, and is expected to return an authenticator session object that
 * will be used by the SDK to manage the authentication process with that authenticator.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * See UIAuthenticatorSession for a discussion of the authentication session lifecycle and sequence of calls
 * made on that object.
 *
 * The authenticator input type for Password authenticator sessions is PasswordInput, which encapsulates
 * the password input by the user.
 *
 * @param title Title of authentication action
 * @param username Username {@link UserInfo#getDisplayName} of current authentication
 *
 * @return UIAuthenticatorSession object for managing the authentication process with this authenticator.
 */
createPasswordAuthSession(title: string, username: string) : UIAuthenticatorSession<PasswordInput>;

   /**
 * Create an authenticator session for the Fingerprint authenticator. This callback is invoked by the SDK as part of
 * an authentication action (e.g Primary or Secondary authentication), when this authenticator needs to be invoked.
 *
 * The callback receives information about the current authentication session such as title, username and any
 * other constraints on the authentication session, and is expected to return an authenticator session object that
 * will be used by the SDK to manage the authentication process with that authenticator.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * See UIAuthenticatorSession for a discussion of the authentication session lifecycle and sequence of calls
 * made on that object. Note, however, that fingerprint authenticator sessions are different from other
 * authenticator sessions in the fact that the authenticator input for these sessions (of type FingerprintInput)
 * is not really the authentication secret but rather the prompt to display when collecting the fingerprint. Actual
 * fingerprint collection is done by the SDK, outside of the invocation of UIAuthenticatorSession#promiseInput.
 *
 * @param title Title of authentication action
 * @param username Username {@link UserInfo#getDisplayName} of current authentication
 *
 * @return UIAuthenticatorSession object for managing the authentication process with this authenticator.
 */
createFingerprintAuthSession(title: string, username: string) : UIAuthenticatorSession<FingerprintInput>;

   /**
 * Create an authenticator session for the native face authenticator. This callback is invoked by the SDK as part of
 * an authentication action (e.g Primary or Secondary authentication), when this authenticator needs to be invoked.
 *
 * The callback receives information about the current authentication session such as title, username and any
 * other constraints on the authentication session, and is expected to return an authenticator session object that
 * will be used by the SDK to manage the authentication process with that authenticator.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * See UIAuthenticatorSession for a discussion of the authentication session lifecycle and sequence of calls
 * made on that object. Note, however, that native face authenticator sessions are different from other
 * authenticator sessions in the fact that the authenticator input for these sessions (of type NativeFaceInput)
 * is not really the authentication secret but rather the prompt to display when collecting the native face sample. Actual
 * face sample collection is done by the SDK, outside of the invocation of UIAuthenticatorSession#promiseInput.
 *
 * @param title Title of authentication action
 * @param username Username {@link UserInfo#getDisplayName} of current authentication
 *
 * @return UIAuthenticatorSession object for managing the authentication process with this authenticator.
 */
createNativeFaceAuthSession(title: string, username: string) : UIAuthenticatorSession<NativeFaceInput>;

   /**
 * Create an authenticator session for the device biometrics authentication authenticator. This callback
 * is invoked by the SDK as part of an authentication action (e.g Primary or Secondary authentication),
 * when this authenticator needs to be invoked.
 *
 * The callback receives information about the current authentication session such as title, username and any
 * other constraints on the authentication session, and is expected to return an authenticator session object that
 * will be used by the SDK to manage the authentication process with that authenticator.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * See UIAuthenticatorSession for a discussion of the authentication session lifecycle and sequence of calls
 * made on that object. Note, however, that device biometrics authenticator sessions are different from other
 * authenticator sessions in the fact that the authenticator input for these sessions (of type DeviceBiometricsInput)
 * is not really the authentication secret but rather the prompt to display when operating the authenticator. Actual
 * authenticator operation is done by the SDK, outside of the invocation of UIAuthenticatorSession#promiseInput.
 *
 * @param title Title of authentication action
 * @param username Username of current authentication
 *
 * @return UIAuthenticatorSession object for managing the authentication process with this authenticator.
 */
createDeviceBiometricsAuthSession(title: string, username: string) : UIAuthenticatorSession<DeviceBiometricsInput>;

   /**
 * Create an authenticator session for the PIN authenticator. This callback is invoked by the SDK as part of
 * an authentication action (e.g Primary or Secondary authentication), when this authenticator needs to be invoked.
 *
 * The callback receives information about the current authentication session such as title, username and the
 * length of the PIN to retrieve, and is expected to return an authenticator session object that will be used by
 * the SDK to manage the authentication process with that authenticator.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * See UIAuthenticatorSession for a discussion of the authentication session lifecycle and sequence of calls
 * made on that object.
 *
 * The authenticator input type for PIN authenticator sessions is PinInput, which encapsulates  the PIN code
 * input by the user.
 *
 * @param title Title of authentication action
 * @param username Username {@link UserInfo#getDisplayName} of current authentication
 * @param pinLength Length of expected PIN input
 *
 * @return UIAuthenticatorSession object for managing the authentication process with this authenticator.
 */
createPinAuthSession(title: string, username: string, pinLength: number) : UIAuthenticatorSession<PinInput>;

   /**
 * Create an authenticator session for the Pattern authenticator. This callback is invoked by the SDK as part of
 * an authentication action (e.g Primary or Secondary authentication), when this authenticator needs to be invoked.
 *
 * The callback receives information about the current authentication session: title, username and the
 * size of the pattern grid in which the pattern should be input. This is expected to return an authenticator session
 * object that will be used by the SDK to manage the authentication process with the pattern authenticator.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * See UIAuthenticatorSession for a discussion of the authentication session lifecycle and sequence of calls
 * made on that object.
 *
 * The authenticator input type for Pattern authenticator sessions is PatternInput. This object is constructed
 * based on user input by the platform Transmit UI Toolkit component for pattern based auth.
 *
 * @param title Title of authentication action
 * @param username Username {@link UserInfo#getDisplayName} of current authentication
 * @param gridWidth Width of pattern input grid, in points
 * @param gridHeight Height of pattern input grid, in points
 *
 * @return UIAuthenticatorSession object for managing the authentication process with this authenticator.
 */
createPatternAuthSession(title: string, username: string, gridWidth: number, gridHeight: number) : UIAuthenticatorSession<PatternInput>;

   /**
 * Create an authenticator session for the OTP authenticator. This callback is invoked by the SDK as part of
 * an authentication action (e.g Primary or Secondary authentication), when this authenticator needs to be invoked.
 *
 * The callback receives information about the current authentication session such as title, username, the list of
 * available OTP trasmission targets, and optionally if one of the OTP targets was automatically triggered -- that
 * OTP target. The callback is expected to return an authenticator session object that will be used by the SDK to
 * manage the authentication process with that authenticator.
 *
 * If the server has automatically triggered an OTP generation to a target, that target will be specified
 * as the autoExecedTarget parameter. Note that this specified auto-execed target may or may not be the active target.
 * For example, if a target was auto executed, then the OTP code was invalidated, and then the user cancelled
 * the authenticator and selected it again (within the same authentication action) -- the autoexeced target is not
 * really active (as the OTP code was expired); howver on the second call to createOtpAuthSession (invoked when the
 * user selected the OTP authenticator again), it will still be passed as the value of autoExecedTarget.
 * The session's setGeneratedOtp call will be invoked to signal which target, if at all, is active.
 * In most cases the target passed to setGeneratedOtp should drive UI rather than autoExecedTarget.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * See UIAuthenticatorSessionOtp and UIAuthenticatorSession for a discussion of the authentication session
 * lifecycle and sequence of calls made on that object. Note that the lifecycle of the OTP authenticator session
 * is specialized since it allows the SDK to notify the authentication UI session about changes to the expected
 * OTP as new OTP codes are generated throughout the session.
 *
 * The authenticator input type for OTP authenticator sessions may be one of the classes derived from OtpInput --
 *   * OtpInputOtpSubmission which encapsulates a submitted OTP password typed by the user,
 *   * OtpInputRequestResend which indicates a request to re-send the OTP to the last selected target, and
 *   * OtpInputSelectTarget which indicates a request to send an OTP to a newly selected target.
 *
 * The SDK will re-invoke the session's UIAuthenticatorSession#promiseInput callback after processing an
 * OtpInputRequestResend or OtpInputSelectTarget request.
 *
 * @param title Title of authentication action
 * @param username Username {@link UserInfo#getDisplayName} of current authentication
 * @param possibleTargets List of possible targets for sending the OTP to. OtpInputSelectTarget requests must specify one of these target objects.
 * @param autoExecedTarget If the Server has automatically triggered OTP transmission to one of the targets, this will identify that target.
 *
 * @return UIAuthenticatorSession object for managing the authentication process with this authenticator.
 */
createOtpAuthSession(title: string, username: string, possibleTargets: Array<OtpTarget>, autoExecedTarget: OtpTarget | null) : UIAuthenticatorSessionOtp;

   /**
 * @deprecated "Disabled and will be removed in future releases"
 *
 */
createFaceAuthSession(title: string, username: string) : UIMultiInputAuthenticationSession<CameraInputResponse,CameraAcquisitionStepDescription>;

   /**
 * Create an authenticator session for the voice detection authenticator. This callback is invoked by the SDK as part of
 * an authentication action (e.g Primary or Secondary authentication), when this authenticator needs to be invoked.
 *
 * The callback receives information about the current authentication session. This is the title and username. The
 * callback is expected to return an authenticator session object that will be used by the SDK to manage the
 * authentication process with that authenticator.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * This is a multi-step input authenticator. See UIAuthenticatorSession and UIMultiInputAuthenticationSession for a
 * discussion of the authentication session lifecycle and sequence of calls made on that object.
 *
 * The authenticator input type for voice authentication sessions is AudioInputResponse, encapsulating a JSON representation
 * of the acquisition result. This input should be generated using the platform voice acquisition control, which
 * will be configured with aquisition parameters on each input step through the supplied AudioAcquisitionStepDescription object
 * for that step.
 *
 * @param title Title of authentication action
 * @param username Username {@link UserInfo#getDisplayName} of current authentication
 *
 * @return UIMultiInputAuthenticationSession object for managing the authentication process with this authenticator.
 */
createVoiceAuthSession(title: string, username: string) : UIMultiInputAuthenticationSession<AudioInputResponse,AudioAcquisitionStepDescription>;

   /**
 * Create an authenticator session for a placeholder authenticator. This callback is invoked by the SDK as part of
 * an authentication action (e.g Primary or Secondary authentication), when this authenticator needs to be invoked.
 *
 * The callback receives information about the current authentication session: title, username and placeholder
 * authetnicator server payload for the authentication process. This is expected to return an authenticator session
 * object that will be used by the SDK to manage the authentication process with the placeholder authenticator.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * See UIAuthenticatorSession for a discussion of the authentication session lifecycle and sequence of calls
 * made on that object.
 *
 * The authenticator input type for placeholder authenticators is PlaceholderInputResponse. This object may either represent
 * a successful authentication -- in which case it is of type PlaceholderAuthSuccessResponse based on a token received
 * by the app from the app server (which in turn received it from the Transmit Server).
 *
 * Alternatively, it may be a PlaceholderAuthFailureResponse, reporting a failure to authenticate, in which case it relays
 * the failure error code (for recovery), as well as a custom message and updated authenticator status.
 *
 * @param placeholderName Name of the placeholder authenticator
 * @param placeholderType Type of the placeholder authenticator
 * @param title Title of authentication action
 * @param username Username {@link UserInfo#getDisplayName} of current authentication
 * @param authenticatorConfiguredData Data configured for the authenticator in the Transmit Server
 * @param serverPayload Placeholder authenticator server payload -- this should be passed to the application server
 *        and from there to Transmit Server when issuing a successful authetnication token.
 
 *
 * @return UIAuthenticatorSession object for managing the authentication process with this authenticator.
 */
createPlaceholderAuthSession(placeholderName: string, placeholderType: string, title: string, username: string, authenticatorConfiguredData: string, serverPayload: string) : UIAuthenticatorSession<PlaceholderInputResponse>;

   /**
 * Create an authenticator session for mobile approve. This callback is invoked by the SDK as part of
 * an authentication action (e.g Primary or Secondary authentication), when this authenticator needs to be invoked.
 *
 * The callback receives information about the current authentication session such as title, username and any
 * other constraints on the authentication session, and is expected to return an authenticator session object that
 * will be used by the SDK to manage the authentication process with that authenticator.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * See UIAuthenticatorSession for a discussion of the authentication session lifecycle and sequence of calls
 * made on that object.
 *
 * The authenticator input type for Mobile Approve authenticator sessions is MobileApproveInput. This object is
 * an empty input response since the authentication input is taking place on a different device out of this SDK's
 * control.
 *
 * This is a polling authenticator session - once approval is created the session starts polling the server waiting
 * until authentication is completed on mobile approval.
 *
 * @param title Title of authentication action
 * @param username Username {@link UserInfo#getDisplayName} of current authentication
 *
 * @return UIAuthenticatorSession object for managing the authentication process with this authenticator.
 */
createMobileApproveAuthSession(title: string, username: string, instructions: string) : UIAuthenticatorSessionMobileApprove;

   /**
 * Create an authenticator session for Totp. This callback is invoked by the SDK as part of
 * an authentication action (e.g Primary or Secondary authentication), when this authenticator needs to be invoked.
 *
 * The callback receives information about the current authentication session such as title and username and any
 * other constraints on the authentication session, and is expected to return an authenticator session object that
 * will be used by the SDK to manage the authentication process with that authenticator.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * See UIAuthenticatorSession for a discussion of the authentication session lifecycle and sequence of calls
 * made on that object.
 *
 * The authenticator input type for Totp authenticator sessions is TotpInput. This object is
 * an empty input response since the authentication input is taking place on a different device out of this SDK's
 * control.
 *
 * @param title Title of authentication action
 * @param username Username {@link UserInfo#getDisplayName} of current authentication
 *
 * @return UIAuthenticatorSession object for managing the authentication process with this authenticator.
 */
createTotpAuthSession(title: string, username: string) : UIAuthenticatorSessionTotp;

   /**
 * Create an authenticator session for the security question authenticator. This callback is invoked by the SDK as part of
 * an authentication action (e.g Primary or Secondary authentication), when this authenticator needs to be invoked.
 *
 * The callback receives information about the current authentication session. This is the title and username. The
 * callback is expected to return an authenticator session object that will be used by the SDK to manage the
 * authentication process with that authenticator.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * This is a multi-step input authenticator. See UIAuthenticatorSession and UIMultiInputAuthenticationSession for a
 * discussion of the authentication session lifecycle and sequence of calls made on that object.
 *
 * The authenticator input type for security questions authentication sessions is SecurityQuestionInputResponse,
 * encapsulating answers to security question challenged as part of the current authentication step.
 * Only questions that were challenged in the current step may be provided, and at least the number of
 * questions specified in the step as the minimum permissible submission must be provided. Failure to comply
 * with either of these requirements will lead to an AppImplementation error being triggered.
 *
 * @param title Title of authentication action
 * @param username Username {@link UserInfo#getDisplayName} of current authentication
 *
 * @return UIMultiInputAuthenticationSession object for managing the authentication process with this authenticator.
 */
createSecurityQuestionAuthSession(title: string, username: string) : UIMultiInputAuthenticationSession<SecurityQuestionInputResponse,SecurityQuestionStepDescription>;

   /**
 * Create an authenticator session for the FIDO2 authenticator. This callback is invoked by the SDK as part of a registration
 * action when this authenticator is registered and the authentication journey is configured to allow FIDO2 credendetial name selection
 * by the user.
 *
 * The callback receives information about the current authentication session. This is the title and username. The
 * callback is expected to return an authenticator session object that will be used by the SDK to manage the
 * registration process with that authenticator.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * The authenticator input type for FIDO2 registration is Fido2InputResponse, encapsulating the desired credential name as part of
 * the authenticator registration.
 *
 * @param title Title of authentication action
 * @param username Username {@link UserInfo#getDisplayName} of current authentication
 *
 * @return UIAuthenticatorSession object for managing the registration process with this authenticator.
 */
createFido2AuthSession(title: string, username: string) : UIAuthenticatorSession<Fido2InputResponse>;

   /**
 * Get user response to a confirmation screen. This callback is invoked by the SDK to execute a confirmation screen
 * policy action.
 *
 * The callback is expected to present a confirmation screen to the user, collect its input and return it
 * asynchronously to the SDK as a ConfirmationInput object.
 *
 * @param title Title of confirmation screen to display.
 * @param text  Text to display in confirmation screen.
 * @param continueText  Label for a confirmation button (pressing this button will cause policy execution to continue)
 * @param cancelText Label for a cancellation button (pressing this button will cause policy execution to abort)
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 *
 * @return A promise object. On successful result, returns: A ConfirmationInput object encoding user choice. For the ConfirmationInput#userChoice property, a value of "0" means continue and a value of "1" means cancel.
 */
getConfirmationInput(title: string, text: string, continueText: string, cancelText: string, actionContext: PolicyAction | null, clientContext: object | null) : Promise<ConfirmationInput>;

   /**
 * Get user response to an information screen. This callback is invoked by the SDK to execute an information screen
 * policy action.
 *
 * The callback is expected to present an information screen to the user, wait for confirmation and return
 * asynchronously to the SDK with a ConfirmationInput object with user selection "-1" once policy evaluation may
 * resume.
 *
 * @param title Title of information screen to display.
 * @param text  Text to display in information screen.
 * @param continueText  Label for the confirmation button
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 *
 * @return A promise object. On successful result, returns: A ConfirmationInput object. The ConfirmationInput#userChoice property must be set to "-1".
 */
getInformationResponse(title: string, text: string, continueText: string, actionContext: PolicyAction | null, clientContext: object | null) : Promise<ConfirmationInput>;

   /**
 * Start a scan QR code session. This callback is invoked by the SDK in response to a policy-initiated request to launch the scan qr code screen.
 *
 * The callback is expected to create a ScanQrSession that represents the UI session for showing the scan QR code screen.
 * The SDK will invoke methods on this callback to drive the scan qr session lifecycle.
 *
 * See documentation of ScanQrSession for more information on the session lifecycle.
 *
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 *
 * @return a ScanQrSession object representing the scan qr code session.
 */
createScanQrSession(actionContext: PolicyAction | null, clientContext: object | null) : ScanQrSession;

   /**
 * Start a wait on ticket session. This callback is invoked by the SDK in response to a policy-initiated request to launch the wait for ticket screen.
 *
 * The callback is expected to create a UITicketWaitSession that represents the UI session for showing the ticket ID (or encoded QR) screen.
 * The SDK will invoke methods on this callback to drive the wait session polling lifecycle.
 *
 * See documentation of UITicketWaitSession for more information on the session lifecycle.
 *
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 *
 * @return a UITicketWaitSession object representing the wait for ticket session.
 */
createTicketWaitSession(actionContext: PolicyAction | null, clientContext: object | null) : UITicketWaitSession;

   /**
 * Start a form session. This callback is invoked by the SDK in response to a policy-initiated request.
 *
 * The callback is expected to create a UIFormSession object that represents the UI session for showing forms.
 * The SDK will invoke methods on this session object as necessary to implement the session lifecycle.
 *
 * @param formId defined in Management UI Server policy as a identifier for this form.
 * @param payload JSON defined in Management UI Server policy to initialize the form session.
 *
 * @return a UIFormSession object representing the form session.
 */
createFormSession(formId: string, payload: object) : UIFormSession;

   /**
 * Start an authentication configuration session. This callback is invoked by the SDK in response to
 * an application-initiated or policy-initiated request to launch the authentication configuration screen.
 *
 * The callback is expected to create a UIAuthenticationConfigurationSession that represents the UI session for
 * setting various authentication parameters  for the user -- most importantly the list of registered authenticators.
 * The SDK will invoke methods on this callback to drive the authentication configuration session lifecycle --
 * passing and updating the list of authenticators for configuration, allowing the app to execute operations
 * on these authenticators by providing a configuration services callback interface, and notifying the app when the session
 * should end.
 *
 * See documentation of UIAuthenticationConfigurationSession for more information on the session lifecycle.
 *
 * @param userId User identification handle {@link UserHandleType} for authentication configuration session.
 *
 * @return a UIAuthenticationConfigurationSession object representing the authentication configuration session.
 */
createAuthenticationConfigurationSession(userId: string) : UIAuthenticationConfigurationSession;

   /**
 * Start an authentication promotion session. This callback is invoked by the SDK in response to a policy-initiated request to launch the authentication promotion screen.
 *
 * The callback is expected to create a UIPromotionSession that represents the UI session for offering registration of a list of supported unregistered authenticators.
 * The SDK will invoke methods on this callback to drive the authentication promotion session lifecycle --
 * passing and updating the list of authenticators for registration.
 *
 * See documentation of createRegistrationPromotionSession for more information on the session lifecycle.
 *
 * @param userId User identification handle {@link UserHandleType} for authentication promotion session.
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked.
 *
 * @return a createRegistrationPromotionSession object representing the authentication promotion session.
 */
createRegistrationPromotionSession(userId: string, actionContext: PolicyAction | null) : UIPromotionSession;

   /**
 * Start a device management session. This callback is invoked by the SDK in response to an application-initiated
 * or policy-initiated request to manage devices.
 *
 * The callback is expected to create a UIDeviceManagementSession that represents the UI session for managing
 * a set of devices belonging to a user. The SDK will invoke methods on this callback to drive the device management
 * session lifecycle -- passing and updating the list of managed devices, allowing the app to execute operations
 * on these devices by providing a device services callback interface, and notifying the app when the session
 * should end.
 *
 * See documentation of UIDeviceManagementSession for more information on the session lifecycle.
 *
 * @param userId User identification handle {@link UserHandleType} for device management session.
 *
 * @return a UIDeviceManagementSession object representing the device management session.
 */
createDeviceManagementSession(userId: string) : UIDeviceManagementSession;

   /**
 * Start an approval management session. This callback is invoked by the SDK in response to an application-initiated
 * or policy-initiated request to manage approvals.
 *
 * The callback is expected to create a UIApprovalSession object that represents the UI session for showing one or
 * more approvals from the approvals session and allowing to act on them. The SDK will invoke methods on this session
 * object as necessary to implement the session lifecycle. These methods allow the SDK to provide the approvals to
 * the Session UI, as well as provide a set of services to the session for carrying out operations on approvals.
 *
 * @param userId User identification handle {@link UserHandleType} for approvals management session.
 *
 * @return a UIApprovalsSession object representing the approval session.
 */
createApprovalsSession(userId: string) : UIApprovalsSession;

   /**
 * Create a TOTP code generation session. This callback is invoked by the SDK as part of the flow that is initiated by
 * invoking {@link TransmitSDKXm#startTotpSessionForUser}, after a successful authentication using the authenticator provisioned for
 * the TOTP code generation (as part of an authentication policy).
 *
 * The callback receives information about the current authentication session such as username and is expected to return
 * a totp code generation session that will be used by the SDK to manage the TOTP code generation process.
 *
 * Note that this call isn't supplied with a clientContext parameter, however the first call on the returned
 * authenticator session object, UIAuthenticatorSession#startSession, *is* supplied with this parameter.
 *
 * See {@link UITotpGenerationSession} for a discussion of the TOTP code generation session lifecycle and sequence of calls
 * made on that object.
 *
 * @param userId User identification handle {@link UserHandleType} for whom this session is requested.
 * @param generatorName The TOTP generation settings as configured on provisioning (server side settings), null is passed incase default is used.
 *
 * @return UITotpGenerationSession object for managing the TOTP generation process.
 */
createTotpGenerationSession(userId: string, generatorName: string | null) : UITotpGenerationSession;

   /**
 * Process a JSON object transmitted by the policy. This callback is invoked by the SDK in response to a
 * JSON Data action defined in the policy. The callback is provided with the JSON data object specified in the
 * policy action for processing by the client, and may request the policy to abort or continue based on processing
 * of the data. Policy execution is suspended until this callback provides (asynchronously) returns the processing
 * result.
 *
 * The callback is expected to perform any application-specific processing on the received JSON data, then
 * return asynchronously a JsonDataProcessingResult object to determine how policy execution should continue.
 *
 * @param jsonData The JSON data sent by the policy
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 *
 * @return A promise object. On successful result, returns: A JsonDataProcessingResult indicating how to resume policy evaluation. See documentation of this type for possible responses.
 */
processJsonData(jsonData: object, actionContext: PolicyAction | null, clientContext: object | null) : Promise<JsonDataProcessingResult>;

   /**
 * Notify policy evaluation rejection. This callback is invoked in response to the policy asking to reject
 * the authentication flow (either using a Reject action or rejection defined for other actions on failure).
 *
 * Implementations should present a rejection screen as defined in the callback parameters to the user,
 * and once policy evaluation may continue (i.e the policy will abort and the SDK invocation will asynchronously return)
 * the implementation must return a ConfirmationInput object asynchronously to the SDK with a user selection value of
 * "-1".
 *
 * @param title Title of rejection screen to display.
 * @param text  Text to display in rejection screen.
 * @param buttonText Label for a confirmation button (to dismiss the screen)
 * @param failureData Optional data which may be specified on the Transmit SP Server for session rejection cases. Holds one JSON field named "value", where it's value type may vary.
 * @param actionContext Information on the policy action currently executing, within which this callback is invoked.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 *
 * @return A promise object. On successful result, returns: A ConfirmationInput object encoding user choice. For the ConfirmationInput#userChoice property, set a value of "-1"
 */
handlePolicyRejection(title: string | null, text: string | null, buttonText: string | null, failureData: object | null, actionContext: PolicyAction | null, clientContext: object | null) : Promise<ConfirmationInput>;

   /**
 * Handle policy redirection. This callback is invoked in response to the policy asking to redirect
 * to another policy with a possibly different user Id.
 *
 * Redirection target policy has a RedirectType indicating which SDK API function is used for starting the next policy.
 * RedirectTypeBind redirects to Id-less device bind policy, having null policyId value.
 * For authentication policy or general policy, RedirectTypeAuthenticate or RedirectTypeInvokePolicy with policyId will be provided, respectively.
 * RedirectTypeBindOrAuthenticate allows the client to decide which type to trigger according to local bind state of the SDK.
 *
 * The client context object passed to the invocation which triggered the redirect (which is the one passed to this callback) will continue to
 * be in effect for the redirected policy.
 *
 * @param redirectType Policy redirect type for next policy invocation.
 * @param policyId  Optional policy Id
 * @param userId Current or different user handle (e.g. userId, idToken) to use in next policy invocation. Null value when redirected to anonymous policy.
 * @param additionalParameters A JSON with additional parameters to be sent for next policy evaluation.
 * @param clientContext The clientContext for the SDK operation invocation for which this callback is invoked.
 *
 * @return A promise object. On successful result, returns: A RedirectInput object encoding client choice.
 */
handlePolicyRedirect(redirectType: RedirectType, policyId: string | null, userId: string | null, additionalParameters: object | null, clientContext: object | null) : Promise<RedirectInput>;

   /**
 * This callback to the UI handler when local authenticator (fingerprint or face id)
 * becomes invalidated during authentication process
 *
 * @param description AuthenticatorDescription of the local authenticator that was invalidated
 * @return A promise object. On successful result, returns: boolean indicating whether the invalidation was acknowledged.
 */
localAuthenticatorInvalidated(description: AuthenticatorDescription, clientContext: object | null) : Promise<boolean>;
}
/**
 * Represents log verbosity levels.
 *
 */
export enum LogLevel {
       /** No logging */
   Off,
       /** Log critical errors only */
   Critical,
       /** Log critical and non-critical errors */
   Error,
       /** Log warnings, critical and non-critical errors */
   Warning,
       /** Log informative messages, warnings, critical and non-critical errors */
   Info,
       /** Log debug messages, informative messages, warnings, critical and non-critical errors */
   Debug
}

/**
 * Identifies types of device fingerprint data collectors
 *
 */
export enum CollectorType {
       /** Collector for cloud accounts data */
   Accounts,
       /** General device data. This collector is mandatory. */
   DeviceDetails,
       /** Contact data stored on the device */
   Contacts,
       /** Device owner data */
   Owner,
       /** Software installed on the device */
   Software,
       /** Device location data. The 'lng' and 'lat' attributes and the 'LocationCountry' collector attributes are mutually exclusive. */
   Location,
       /** Device reverse geolocation data, specifically country. Disabled by default. The 'lat' and 'lng' attributes of the 'Location' collector and the attributes of this collector are mutually exclusive.*/
   LocationCountry,
       /** Bluetooth accessory data */
   Bluetooth,
       /** Supported modules. This collector is mandatory. */
   ExternalSDKDetails,
       /** Supported hw authenticators. This collector is mandatory. */
   HWAuthenticators,
       /** Capabilities, such as fingerprint, audiocapture, persistent keys. This collector is mandatory. */
   Capabilities,
       /** Larger sized fingerprint data */
   LargeData,
       /** Local enrollments registration status. This collector is mandatory. */
   LocalEnrollments,
       /** General device fingerprint data. This collector is mandatory. */
   DeviceFingerprint,
       /** Hosting application's permissions details. */
   AppPermissions
}

/**
 * Identifies types of data transfer encryption modes (on top of any connection security used, like SSL), which
 * could be considered as "double" encryption, for a new authentication session.
 *
 */
export enum ConnectionCryptoMode {
       /** No encryption is added over any connection security setting */
   None,
       /** Cryptography handshake is performed over the current data transfer and encryption begins when it's complete */
   Credentials,
       /** Cryptography handshake is performed prior to any data transfer, thus all data transfer is encrypted */
   Full
}

/**
 * Represents parameters that define the connection between this app and the authentication server.
 *
 */
export abstract class SDKConnectionSettings { 

/**
 * URL of the Transmit Security server to communicate with. The SDK will use this URL whenever
 * it wants to communicate with Transmit Security server. Access to a URL relative to this URL should be
 * routed relative to the root URL of the server.
 */
   public getServerAddress() : string;

/**
 * URL of the Transmit Security server to communicate with. The SDK will use this URL whenever
 * it wants to communicate with Transmit Security server. Access to a URL relative to this URL should be
 * routed relative to the root URL of the server.
 */
   public setServerAddress(serverAddress : string) : void;

/**
 * Realm in the Transmit Security Server to communicate with. If this is left as an empty string,
 * the default realm will be used.
 */
   public getRealm() : string;

/**
 * Realm in the Transmit Security Server to communicate with. If this is left as an empty string,
 * the default realm will be used.
 */
   public setRealm(realm : string) : void;

/**
 * Application ID for this application, as defined in the management console. All policy invocations issued
 * from the SDK will be for policies within this application.
 */
   public getAppId() : string;

/**
 * Application ID for this application, as defined in the management console. All policy invocations issued
 * from the SDK will be for policies within this application.
 */
   public setAppId(appId : string) : void;

/**
 * SDK API token for use with the Transmit Server. This should be an API token name which
 * was provisioned in the Transmit Server management UI console.
 */
   public getTokenName() : string;

/**
 * SDK API token for use with the Transmit Server. This should be an API token name which
 * was provisioned in the Transmit Server management UI console.
 */
   public setTokenName(tokenName : string) : void;

/**
 * SDK API token for use with the Transmit Server. This should be the token value of an API token
 * provisioned in the Transmit Server management UI console.
 */
   public getToken() : string;

/**
 * SDK API token for use with the Transmit Server. This should be the token value of an API token
 * provisioned in the Transmit Server management UI console.
 */
   public setToken(token : string) : void;

/**
 * The data transfer encryption mode to be used on top of any connection security for a new authentication session
 */
   public getCryptoMode() : ConnectionCryptoMode;

/**
 * The data transfer encryption mode to be used on top of any connection security for a new authentication session
 */
   public setCryptoMode(cryptoMode : ConnectionCryptoMode) : void;

/**
 * Create a server connection object with the specified parameters.
 *
 * @param serverAddress serverAddress for the newly created object
 * @param appId appId for the newly created object
 * @param tokenName tokenName for the newly created object
 * @param token token for the newly created object
 */
   public static create(serverAddress: string, appId: string, tokenName: string, token: string) : SDKConnectionSettings;

/**
 * Create a server connection object with the specified parameters.
 *
 * @param serverAddress serverAddress for the newly created object
 * @param appId appId for the newly created object
 * @param tokenName tokenName for the newly created object
 * @param token token for the newly created object
 * @param cryptoMode The data transfer encryption mode
 */
   public static createWithCryptoMode(serverAddress: string, appId: string, tokenName: string, token: string, cryptoMode: ConnectionCryptoMode) : SDKConnectionSettings;

   /**
 * @param isHttp if true, flow id will be sent as http header, else flow id will be sent as a sdk header
 */
public abstract setSendFlowIdAsHttpHeader(isHttp: boolean) : void;

   public abstract shouldSendFlowIdAsHttpHeader() : boolean;
}
/**
 * Represents parameters that define parameters for procedures and elements which take part in the various
 * cryptography algorithms deployed by the SDK.
 *
 */
export abstract class ClientCryptoSettings { 

/**
 * Specifying the key size resulting by deploying the PBKDF algorithm.
 */
   public getLocalEnrollmentKeySizeInBytes() : number;

/**
 * The number of iterations to deploy in the PBKDF algorithm (defaults to 1000).
 */
   public getLocalEnrollmentKeyIterationCount() : number;

/**
 * The number of iterations to deploy in the PBKDF algorithm (defaults to 1000).
 */
   public setLocalEnrollmentKeyIterationCount(localEnrollmentKeyIterationCount : number) : void;

/**
 * Create a crypto settings object with the specified parameters.
 *
 * @param keygenIterationCount The number of iterations to deploy in the PBKDF algorithm (large numbers have implications on performance)
 */
   public static create(keygenIterationCount: number) : ClientCryptoSettings;
}
/**
 * A push request payload denoting a request to invoke a mobile-approval session. Objects
 * of this class encode parameters for running the approval session. Typically they are
 * created based on data sent via a push notification, and then transferred to the SDK
 * (e.g. TransmitSDKXm#startApprovalsSessionForPushedRequest) to create an approval session based on them.
 *
 * Application developers may choose to relay push notifications externally to the platform,
 * implement their own push notification parsing process and creating push request payloads
 * synthetically; for example, an application may encode a user ticket in some field in push
 * requests sent to the application, and then extract that field when the push notification is received
 * and pass it to createWithUserTicket. In this case, the application completely controls the
 * push notification format and, in fact, transport.
 *
 * Alternatively, if the application is able to attach a JSON object payload to the push notification,
 * it can use createWithJsonPayload, passing it the JSON payload attached to the message. The JSON
 * payload is generated by the Transmit Server and passed to the push notification service provider
 * for inclusion in the push notification. This way, the Transmit platform takes care of relaying
 * push requests to the application (except for the transport itself), and the application only needs to
 * implant the payload in a preferred place in the push message (at the server), and extract it from
 * the push message in the client.
 *
 * Finally, if the application is using the Transmit builtin push service, the application only needs
 * to provide the JSON payload from the notification to createWithJsonPayload; this constructor
 * will locate the push request payload in that JSON payload as implanted by the server.
 *
 */
export abstract class MobileApprovePushRequestPayload extends PushRequestPayload { 

   /**
 * Return the semantic body content the push notification should display.
 */
public abstract body() : string;

   /**
 * Return the origin of the push notification.
 */
public abstract source() : string;

   /**
 * Return the user ID specified by this mobile approve push request payload, if any.
 */
public abstract userId() : string;

   /**
 * Return the ticket specified by this mobile approve push request payload, if any.
 */
public abstract ticket() : string;

/**
 * Construct a synthetic push payload encoding a request to show approvals for a specific user ID.
 *
 * @param userId User identification handle {@link UserHandleType} for which approvals should be displayed to process this request.
 */
   public static createWithUserId(userId: string) : MobileApprovePushRequestPayload;

/**
 * Construct a synthetic push payload encoding a request to show approvals given a specific user ticket.
 * User tickets allow identifying users without including the user ID in the push payload. This is often
 * a desired approach to since it's preferable not to include sensitive information as part of push notifications.
 * The ticket is generated and provided to the push notification provider at the server. It refers
 * to a specific user and has an expiation period, after which it is no longer valid.
 *
 * @param ticket User ID for which approvals should be displayed to process this request.
 */
   public static createWithUserTicket(ticket: string) : MobileApprovePushRequestPayload;

/**
 * Construct a push payload based on the JSON payload generated at the Transmit Server
 * and included in the push notification.
 *
 * @param payload JSON Object attached to the push notification (or at the root of the notification when using the Transmit standard push provider).
 */
   public static createWithJsonPayload(payload: object) : MobileApprovePushRequestPayload;
}
/**
 * An object referring to a suspended control flow execution.
 */
export class SuspensionContext { 
}
/**
 * An application-provided log handler. The application providers this to the SDK by invoking
 * TransmitSDKXm#setExternalLogger. From that point onwards the SDK will invoke this logger
 * to log messages.
 *
 */
export interface TransmitSDKLogger { 

   /**
 * Request to log a message.
 *
 * @param level Log level in which message should be logged
 * @param category A tag describing the topic or category of the message
 * @param message Message to log
 */
log(level: LogLevel, category: string, message: string) : void;
}
/**
 * Entry point to the TSX API. This interface encapsulates all base services provided by the TSX API.
 * It is the starting point for initializing, configuring and invoking authentication processes.
 *
 */
export interface TransmitSDKXm { 

   /**
 * @return A {@link VersionInfo} object carrying information regarding the versions of the elements comprising this SDK and its APIs.
 */
getVersionInfo() : VersionInfo;

   /**
 * Set the connection settings of the SDK for this application. This includes parameters such as server address,
 * API tokens, and application ID.
 *
 * The connection settings object passed to this call is copied and used. Changes to the connection settings object
 * after it was passed to the SDK will not have any effect.
 *
 * @param connectionSettings Connection settings to apply to the SDK.
 */
setConnectionSettings(connectionSettings: SDKConnectionSettings) : void;

   /**
 * Optionally, set the cryptographic algorithms parameters in the SDK for this application. This includes parameters such as PBKDF iteration count.
 * For more details please see {@link ClientCryptoSettings}.
 *
 * The connection settings object passed to this call is copied and used. Changes to the connection settings object
 * after it was passed to the SDK will not have any effect.
 *
 * @param clientCryptoSettings Cryptographic algorithms parameters to deploy in the SDK.
 */
setClientCryptoSettings(clientCryptoSettings: ClientCryptoSettings) : void;

   /**
 * Set the list of enabled device fingerprinting data collectors.
 * By default all data collectors are enabled.
 *
 * @param enabledCollectors list of enabled device fingerprinting data collectors.
 */
setEnabledCollectors(enabledCollectors: Array<CollectorType>) : void;

   /**
 * Set the list of enabled device fingerprinting data collectors for anonymous journies.
 * By default all data collectors are enabled.
 *
 * @param enabledCollectors list of enabled device fingerprinting data collectors.
 */
setEnabledCollectorsForAnonymousJourneys(enabledCollectors: Array<CollectorType>) : void;

   /**
 * Set the SDK invalid user recovery mode. This governs how the SDK behaves when encountering an error that indicates mismatch between
 * the user record on the client and server state. This includes errors {@link AuthenticationErrorCode#InvalidDeviceBinding} and
 * {@link DeviceNotFound}. Depending on the set recovery mode, the SDK may either just report the error or attempt to clear the user record
 * before reporting it. Whether the SDK has performed such deletion is reported in the error's UserRecordDeleted property.
 *
 * For API level  until 9, the default behavior is to not attempt to delete user records.
 * For API level 9 onwards, the default behavior is to attempt to delete user records.
 *
 * @param recoveryMode Recovery mode to set for invalid user record errors.
 */
setInvalidUserRecordRecoveryMode(recoveryMode: InvalidUserRecordRecoveryMode) : void;

   /**
 * Set the SDK client API level. This controls different SDK behaviors as documented in the user guide and throughout the
 * API definitions. If this is not set prior to invocation of {@link #initialize}, the system will assume the latest API level.
 * It is an error to invoke this API more than once on an SDK instance.
 *
 * @param apiLevel Client API level to enable for the SDK.
 */
setClientApiLevel(apiLevel: number) : void;

   /**
 * Set the logging level for the SDK's internal logger. See the LogLevel enumeration for available logging levels and their meanings.
 * The default log level is LogLevel#Error.
 *
 * @param level logging level for the SDK.
 */
setLogLevel(level: LogLevel) : void;

   /**
 * Set an external logger for this SDK in addition to the default logger. The external logger is notified about every log message generated by the SDK.
 *
 * @param logger External logger to use.
 */
setExternalLogger(logger: TransmitSDKLogger) : void;

   /**
 * Connect a transport provider to the SDK. The connected transport provider will be in use for all communication
 * between the SDK and the server. Once the SDK is initialized the connect transport provider must not be changed;
 * doing so will result in undefined behavior.
 *
 * @param transportProvider The TransportProvider object to connect to the SDK.
 */
setTransportProvider(transportProvider: TransportProvider) : void;

   /**
 * Set the UI handler for policy invocations. This is the object that will be used by the SDK to
 * ask the client to display UI and provide input. The UI handler set at the time of policy
 * invocation will be used throughout that entire invocation, even if during invocation another
 * call to setUiHandler replaces the UI handler. The new UI handler will go into effect starting
 * with subsequent policy invocations.
 *
 * @param uiHandler UI handler object to use for subsequent policy invocations.
 *
 * @throw {@link AuthenticationError} An invalid UI handler was provided to the SDK.
 */
setUiHandler(uiHandler: UIHandler) : void;

   /**
 * Notify the SDK that a push token is associated with this device. The push token will be registered with
 * the Transmit Server and will be used for subsequent attempts by the platform to send push notification
 * to this device, e.g as part of mobile approve.
 *
 * @param pushToken The updated push token to use for this device.
 *
 */
setPushToken(pushToken: string) : void;

   /**
 * Set persist user data setting. This setting determines whether or not the SDK will save user data on the device.
 * The setting configured at the time of session creation will be used throughout that entire invocation,
 * even if during invocation another call to setPersistUserData modifies this setting. The modified setting will go into effect starting
 * with subsequent policy invocations. The invocation of setPersistUserData doesn't affect the data already saved on the device,
 * therefore if the application wishes to clear existing data as well, it should invoke {@link clearDataForUser}.
 * By default, this setting is set to true.
 *
 * @param persistUserData boolean indicating whether or not to save user data on the device.
 */
setPersistUserData(persistUserData: boolean) : void;

   /**
 * Load a plugin into the SDK, given the plugin name and configuration
 * specific to that plugin.
 *
 * @param pluginName Name of plugin to load
 * @param config Configuration for plugin
 */
installPlugin(pluginName: string, config: object) : void;

   /**
 * Initialize the SDK. This must be called after the configuration calls but before actually invoking
 * authentication requests.
 * @return A promise object. On successful result, returns: boolean flag indicating successful initialization.On error, returns: {@link AuthenticationError} An error occurred during the initialization
 */
initialize() : Promise<boolean>;

   /**
 * Construct a push payload based on the JSON payload generated at the Transmit Server and included in the push notification.
 *
 * @param payload JSON Object attached to the push notification (or at the root of the notification when using the Transmit standard push provider).
 */
pushRequestPayloadFromJSON(payload: object) : PushRequestPayload;

   /**
 * Query whether TOTP is provisioned on this device for u user. 'provisioned' means that the user has completed a TOTP provisioning action,
 * in an authentication policy, on this device.
 *
 * @param userId User identification handle {@link UserHandleType} to use for TOTP provisioning query.
 * @param generatorName The TOTP generation settings as configured on provisioning (server side settings), in case of null, "default" is used.
 *
 * @return 'true' if TOTP is provisioned for the user on this device, 'false' otherwise.
 */
isTotpProvisionedForUser(userId: string, generatorName: string | null) : boolean;

   /**
 * Invoke a TOTP code generation session. This initiates the TOTP code generation process, which consists of two main stages:
 *  a. Authentication which the user is required to perform with the authenticator which he chose during the TOTP provisioning.
 *  b. (Optional) Acquisition of a server generated challenge presented on the client which is attempting to authenticate with TOTP.
 *  c. TOTP code generation session during which, TOTP codes are generated for the user in order to be used as OTP authentication wherever required.
 *
 * As part of this process execution the SDK will invoke the different callbacks in the currently set
 * UI handler in order to interact with the application and user.
 *
 * It is illegal to call {@link #startTotpSessionForUser} on a user for whom TOTP wasn't provisioned on this device.
 *
 * @param userId User identification handle {@link UserHandleType} to use for the TOTP code generation process.
 * @param challengeBased True iff this TOTP session should involve acquisition of a server generated challenge.
 * @param generatorName The TOTP generation settings as configured on provisioning (server side settings), in case of null, "default" is used.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the context of this session invocation.
 * @return A promise object. On successful result, returns: A boolean indicating the status of the request completion.On error, returns: {@link AuthenticationError} upon unsuccessful completion of the session invocation.
 */
startTotpSessionForUser(userId: string, challengeBased: boolean, generatorName: string | null, clientContext: object | null) : Promise<boolean>;

   /**
 * Creates an object holding the TOTP code generation related attributes (e.g. *generatorName*, *challenge*) as extracted from
 * a canonical string reprasention (e.g. as produced by scanning a designated QR code).
 * A canonical representation of TOTP code generation attributes, for instance, is generated and expressed in the form of a QR barcode by the
 * Transmit server when a "web API" application is configured to enable authentication with a TOTP authenticator using a "Canonical QR Code"
 * challenge format. This challnge is supposed to be used by the mobile application providing the TOTP code for the web application authenticator.
 * See {@link #TotpGenerationRequest} for more details.
 *
 * @param userId User identification handle {@link UserHandleType} for whom this QR representation is to be processed.
 * @param repr The canonical string reprasention.
 *
 * @return An object holding the TOTP related attributes.
 * @throws AuthenticationError in case no attributes matching the TOTP provisioning on the current device could be found in the canonical string.
 */
totpGenerationRequestForUserFromCanonicalString(userId: string, repr: string) : TotpGenerationRequest;

   /**
 * Functions, essentially, is the same as with {@link #startTotpSessionForUser} but deducts the requirement of a chellenge and the challenge it self from
 * the given *attributes* argument. Thus, even if a challenge is required, the {@link UITotpGenerationSession#promiseChallengeInput} callback
 * @return 
 */
startTotpSessionWithRequest(request: TotpGenerationRequest, clientContext: object | null) : Promise<boolean>;

   /**
 * Invoke a binding policy. This initiates the processing of the single configured binding policy in the app,
 * actually performing the device binding and finishing by returning the result of the policy execution asynchronously.
 *
 * As part of policy execution the SDK will invoke the different callbacks in the currently set
 * UI handler in order to interact with the application and user.
 *
 * It is illegal to call bind for a bound user on this device. Doing so will result in an AppImplementation error
 * code.
 *
 * A succesful bind operation is also equivalent to login -- meaning that it creates a login session and sets the
 * current primary session to this session. A failed login leave the SDK without a session.
 * It is illegal to invoke this call with a current primary session.
 *
 * @param userId User id {@link UserHandleType#UserId} to use for authentication action
 * @param additionalParameters A JSON with additional parameters to be sent for policy evaluation.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the context of this policy invocation.
 * @return A promise object. On successful result, returns: An authentication result object upon successful completion of the binding operation invocation, with an optional token.On error, returns: AuthenticationError upon unsuccessful completion of the policy invocation.
 */
bind(userId: string, additionalParameters: object | null, clientContext: object | null) : Promise<AuthenticationResult>;

   /**
 * same as {@link #bind}, with options
 * @return 
 */
bindWithOptions(userId: string, additionalParameters: object | null, clientContext: object | null, options: BindInvocationOptions | null) : Promise<AuthenticationResult>;

   /**
 * Query whether this device is bound for a user. 'bound' means that a binding authentication policy was completed successfully for this user on this
 * device. This status may change if this device storage is purged. This method may return 'True' for a user but the server may still revoke the binding
 * status of this device for this user on later requests.
 *
 * @param userId User identification handle {@link UserHandleType} to use for the binding status query
 *
 * @return 'true' if this device is marked as bound for this user, 'false' otherwise.
 */
isBoundForUser(userId: string) : boolean;

   /**
 * Returns a list of objects holding information about each known user on this device.
 */
getUsersInfo() : Array<UserInfo>;

   /**
 * Looks up the user info based on provided user identifer.
 *
 * @param userHandle User identification handle {@link UserHandleType} to use for the binding status query
 *
 * @return {@link UserInfo} if the provided handle mapped to an existing user record or raises an error otherwise.
 */
getUserInfo(userHandle: string) : UserInfo;

   /**
 * Indicate whether current device supports cryptographic binding.
 *
 * @return 'true' if this device supports cryptographic binding, 'false' otherwise.
 */
deviceSupportsCryptoBinding() : boolean;

   /**
 * @deprecated "please use 'getUsersInfo' instead"
 * Return the list of users for whom this device is currently bound. These are all and only users for which #isBoundForUser
 * would return true.
 *
 * @return List of user IDs for whom the device is bound and have a userId {@link UserHandleType#UserId} property.
 */
getBoundUserIds() : Array<string>;

   /**
 * @deprecated "please use 'getUsersInfo' instead"
 * Return the list of users who previously completed a successful login on this device.
 *
 * @return List of user IDs who previously completed a successful login on this device and have a userId {@link UserHandleType#UserId} property.
 */
getKnownUserIds() : Array<string>;

   /**
 * Invoke an authentication policy. This initiates the processing of an authentication policy
 * and returns the result of the policy execution asynchronously. This also starts a new authentication session
 * that will be saved by the SDK until a call to logout.
 *
 * As part of policy execution the SDK will invoke the different callbacks in the currently set
 * UI handler in order to interact with the application and user.
 *
 * It is illegal to invoke this call with a current primary session; invoke #logout if there's an existing session
 * and you'd like to start a new one.
 *
 * @param userId User identification handle {@link UserHandleType#UserId} to use for authentication action
 * @param policyId ID of policy to invoke
 * @param additionalParameters A JSON with additional parameters to be sent for policy evaluation.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the context of this policy invocation.
 * @return A promise object. On successful result, returns: An authentication result object upon successful completion of the policy invocation, with an optional token.On error, returns: AuthenticationError upon unsuccessful completion of the policy invocation.
 */
authenticate(userId: string, policyId: string | null, additionalParameters: object | null, clientContext: object | null) : Promise<AuthenticationResult>;

   /**
 * same as {@link #authenticate}, with options
 * @return 
 */
authenticateWithOptions(userId: string, policyId: string | null, additionalParameters: object | null, clientContext: object | null, options: AuthenticateInvocationOptions | null) : Promise<AuthenticationResult>;

   /**
 * Same as {@link #authenticate} but the app should provide an {@link UserHandleType#IdToken} which
 * @return 
 */
authenticateWithIdToken(token: string, policyId: string | null, additionalParameters: object | null, clientContext: object | null) : Promise<AuthenticationResult>;

   /**
 * same as {@link #authenticateWithIdToken} authenticateWithId, with options
 * @return 
 */
authenticateWithIdTokenWithOptions(token: string, policyId: string | null, additionalParameters: object | null, clientContext: object | null, options: AuthenticateInvocationOptions | null) : Promise<AuthenticationResult>;

   /**
 * Ends an authentication session. This call invalidates and ends an authentication session created by #authenticate
 * or #bind.
 *
 * It is illegal to call logout while the current session is in use. The current session is in use if one or more
 * of the following calls has been made and didn't asynchronously return yet: #bind, #authenticate, #invokePolicy,
 * #startAuthenticationConfiguration, #startAuthenticationConfigurationWithToken, #startDeviceManagementSession,
 * #startApprovalsSessionForCurrentSession.
 *
 * - There's a control flow running that didn't complete;
 * @return A promise object. On successful result, returns: An authentication result object upon successful completion of the operation.On error, returns: AuthenticationError upon unsuccessful logoff
 */
logout() : Promise<boolean>;

   /**
 * Invoke a policy. This initiates the invocation of a server policy, without creating a new authentication session.
 * There must be an existing session when this is invoked by the user.
 * Returns the result of the policy execution asynchronously.
 * As part of policy execution the SDK will invoke the different callbacks in the currently set
 * UI handler in order to interact with the application and user.
 *
 * It is illegal to invoke this call while a control flow is already running for the current session.
 *
 * @param policyId ID of policy to invoke
 * @param additionalParameters A JSON with additional parameters to be sent for policy evaluation.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the context of this policy invocation.
 * @return A promise object. On successful result, returns: An authentication result object upon successful completion of the policy invocation, with an optional token.On error, returns: AuthenticationError upon unsuccessful completion of the policy invocation.
 */
invokePolicy(policyId: string | null, additionalParameters: object | null, clientContext: object | null) : Promise<AuthenticationResult>;

   /**
 * same as {@link invokePolicy}, with options
 * @return 
 */
invokePolicyWithOptions(policyId: string | null, additionalParameters: object | null, clientContext: object | null, options: PolicyInvocationOptions | null) : Promise<AuthenticationResult>;

   /**
 * Cancel the current running control flow for the primary session, if any. This will make a best-effort attempt
 * to terminate the currently executing policy (whether invoked by #bind, #authenticate, #invokePolicy, or a
 * session service for the approvals / device management / authenticator configuration sessions).
 *
 * If successful, cancellation will cause the SDK invocation that started the control flow to return with an
 * authentication error of type AuthenticationErrorCode#AppImplementation.
 *
 * Requesting a cancellation may still result in the running control flow completing succesfully -- depending
 * on the policy state at the time of cancellation invocation.
 *
 */
cancelCurrentRunningControlFlow() : void;

   /**
 * Resume a previously suspended control flow. This can be invoked after the original SDK instance executing the control flow has prepared
 * for suspension, and possibly destroyed. A new SDK instance can then resume the suspended control flow. Any action occurring as successful
 * completion of the original control flow (e.g bind, authenticate) will complete pending successful resumption of the control flow.
 *
 * When resuming a suspended control flow, parameters can be provided to it. This allows a control flow to request suspension to allow input collection,
 * and resumption of the control flow with the collected input.
 *
 * @param suspensionContext A context object that represents the suspended control flow. If this is not provided, a default control flow will be resumed.
 * @param resumptionParameters Parameters to pass to the control flow execution context when resuming.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the
 * @return 
 */
resumeSuspendedControlFlow(suspensionContext: SuspensionContext | null, resumptionParameters: object, clientContext: object | null) : Promise<AuthenticationResult>;

   /**
 * Start an authentication configuration session. This will trigger invocation of the
 * UIHandler#createAuthenticationConfigurationSession call followed by session lifecycle management on the
 * returned object, and will async-return once the session ends.
 *
 * See UIAuthenticationConfigurationSession for more details on the session lifecycle.
 *
 * This call requires that an active, logged-in session exists for this SDK object; the user whose authentication
 * configuration will be updated is determined by the current session.
 *
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the
 * context of this invocation.
 * @return A promise object. On successful result, returns: true on completion of configuration session.On error, returns: {@link AuthenticationError} upon unsuccessful completion of the session
 */
startAuthenticationConfiguration(clientContext: object | null) : Promise<boolean>;

   /**
 * Start an authentication configuration session based on an externally provided authentication token.
 * This is identical to #startAuthenticationConfiguration but rather than relying on an active current session,
 * it is done based on an authentication token provided by the client to obtain access to the configuration session.
 *
 * @param configurationToken A configuration menu access token, provided externally to the application.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the
 * context of this invocation.
 * @return A promise object. On successful result, returns: true on completion of configuration session.On error, returns: {@link AuthenticationError} upon unsuccessful completion of the session
 */
startAuthenticationConfigurationWithToken(configurationToken: string, clientContext: object | null) : Promise<boolean>;

   /**
 * Start a device management session. This will trigger invocation of the UIHandler#createDeviceManagementSession
 * call followed by session lifecycle management on the returned object, and will async-return once the session ends
 * either by calling the DeviceManagementSessionServices#finishSession or
 * DeviceManagementSessionServices#removeCurrentDeviceAndFinishSession.
 *
 * See UIDeviceManagementSession for more details on the session lifecycle.
 *
 * This call requires that an active, logged-in session exists for this SDK object; the user whose
 * devices will be managed is determined by the current session.
 *
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the
 * context of this invocation.
 * @return A promise object. On successful result, returns: true on completion of management session.On error, returns: {@link AuthenticationError} upon unsuccessful completion of the session
 */
startDeviceManagementSession(clientContext: object | null) : Promise<boolean>;

   /**
 * Start a mobile approval management session. This will trigger invocation of the
 * UIHandler#createApprovalsSession call followed by session lifetime management, and will async-return
 * once the session ends.
 *
 * See UIApprovalsSession for more details on the session lifecycle.
 *
 * This call requires that an active, logged-in session exists for this SDK; the user
 * for whom the approval management session will be started is determined by the current session.
 *
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the
 * context of this invocation.
 * @return A promise object. On successful result, returns: true on completion of approvals session.On error, returns: {@link AuthenticationError} upon unsuccessful completion of the session
 */
startApprovalsSessionForCurrentSession(clientContext: object | null) : Promise<boolean>;

   /**
 * Start a mobile approval management session based on a push request payload. This will trigger invocation of the
 * UIHandler#createApprovalsSession call followed by session lifetime management, and will async-return
 * once the session ends.
 *
 * See UIApprovalsSession for more details on the session lifecycle.
 *
 * The approval session is run with parameters specified in the pushRequestPayload parameter;
 * the user for whom the push approval is addressed is either specified verbatim on the payload or
 * as a one-time token generated by the Transmit Server, that identifies the user at the server. See the
 * the MobileApprovePushRequestPayload class for a discussion on how push requests can be relayed
 * to the application.
 *
 * This call does not affect the current active session for the SDK; if the push request identifies
 * a user other than the currently logged in user for a current session in the SDK, only the approvals
 * session will run based on a separate session; other SDK calls continue to use the default session.
 *
 *
 * @param pushRequestPayload A push notification payload object that encodes a request to start an approval session.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the
 * context of this invocation.
 * @return A promise object. On successful result, returns: true on completion of approvals session.On error, returns: {@link AuthenticationError} upon unsuccessful completion of the session
 */
startApprovalsSessionForPushedRequest(pushRequestPayload: MobileApprovePushRequestPayload, clientContext: object | null) : Promise<boolean>;

   /**
 * same as {@link #startApprovalsSessionForPushedRequest}, with options
 * @return 
 */
startApprovalsSessionForPushedRequestWithOptions(pushRequestPayload: MobileApprovePushRequestPayload, clientContext: object | null, options: ApprovalPolicyInvocationOptions | null) : Promise<boolean>;

   /**
 * Invoke an anonymous user policy. This initiates the processing of anonymous policy in the server app, starts an anonymous policy
 * and returns the result of the policy execution asynchronously.
 *
 * As part of policy execution the SDK will invoke the different callbacks in the currently set
 * UI handler in order to interact with the application and user.
 *
 * This call does not affect the current active session for the SDK, if one exists.
 *
 * @param policyId ID of policy to invoke
 * @param additionalParameters A JSON with additional parameters to be sent for policy evaluation.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the context of this policy invocation.
 * @return A promise object. On successful result, returns: An authentication result object upon successful completion of the anonymous operation invocation.On error, returns: AuthenticationError upon unsuccessful completion of the policy invocation.
 */
invokeAnonymousPolicy(policyId: string | null, additionalParameters: object | null, clientContext: object | null) : Promise<AuthenticationResult>;

   /**
 * same as {@link #invokeAnonymousPolicy}, with options
 * @return 
 */
invokeAnonymousPolicyWithOptions(policyId: string | null, additionalParameters: object | null, clientContext: object | null, options: AnonymousPolicyInvocationOptions | null) : Promise<AuthenticationResult>;

   /**
 * Invoke an anonymous user policy, based on an inline authentication response.
 *
 * Use this function to start processing an anonymous journey invocation where the initial invocation
 * of the journey has already occurred. This call receives the response to this initial journey
 * invocation request and continues processing the journey from that point.
 *
 * For example, an implementation may initiate the anonymous journey through server-to-server
 * communication, or by requesting an IDP page with an embedded anonymous invocation response.
 * In both of these cases the response of this invocation will be provided by the caller to this function.
 *
 * As part of policy execution the SDK will invoke the different callbacks in the currently set
 * UI handler in order to interact with the application and user.
 *
 * This call does not affect the current active session for the SDK, if one exists.
 *
 * @param inlineInvokeResposne A JSON data representing an inline authentication response.
 * @param clientContext An object map for client use. This map will be passed to all callbacks invoked in the context of this policy invocation.
 * @return A promise object. On successful result, returns: An authentication result object upon successful completion of the anonymous operation invocation.On error, returns: AuthenticationError upon unsuccessful completion of the policy invocation.
 */
invokeAnonymousPolicyWithInlineInvokeResponse(inlineInvokeResposne: object, clientContext: object | null) : Promise<AuthenticationResult>;

   /**
 * Clear data for a specific user. If data for the user exists on the device, it will be deleted.
 *
 * It is illegal to invoke this call with an active current session.
 *
 *
 * @param userId User identification handle {@link UserHandleType} for whom data should be cleared.
 */
clearDataForUser(userId: string) : void;

   /**
 * Clear all SDK data from the device
 *
 * It is illegal to invoke this call with an active current session.
 *
 */
clearAllData() : void;

   /**
 * Generate a debug PIN for the control flow started with a provided client context.
 *
 * It is illegal to invoke this call with a client context that wasn't used in one of the
 * journey-starting calls.
 * @return A promise object. On successful result, returns: A PIN code that can be used in the admin console to start debugging the journey.
 */
generateDebugPinForControlFlow(clientContext: object) : Promise<string>;

   /**
 * Configure the UI assets download mode, there are two modes for the configuration, Disable and DownloadOnInit.
 * The default is DownloadOnInit.
 *
 * @param uiAssetsDownloadMode UIAssetsDownloadMode  UI assets download mode.
 */
setUiAssetsDownloadMode(uiAssetsDownloadMode: UIAssetsDownloadMode) : void;

   /**
 * API to set the locale of the Client Strings feature that application wants to work with,
 * this API will fetch the require locale table strings from the server and will update the strings table with the new response,
 * if the require locale table strings doesn't exist the response will return an error.
 * The API is async, the default is the preferred language that app work with it.
 *
 * @return On error, returns: {@link AuthenticationError} upon unsuccessful completion of the session
 */
setLocale(locale: string) : Promise<boolean>;

   /**
 * Reset any current primary session, and/or default continuation context. Ensures that
 * the SDK is in a "fresh start" mode w.r.t sessions. Does not communicate with the server
 * @return On error, returns: {@link AuthenticationError} upon unsuccessful completion of the session
 */
resetCurrentSession() : Promise<boolean>;
}
}
